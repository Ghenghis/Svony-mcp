#!/usr/bin/env python3
"""
RAG Exploit Scanner - Comprehensive vulnerability discovery
Scans Evony client and AutoEvony for all cheat opportunities
"""

import sys
import json
import re
from pathlib import Path
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from enum import Enum
from datetime import datetime

# Add parent to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

class ExploitCategory(Enum):
    INTEGER_OVERFLOW = "integer_overflow"
    RACE_CONDITION = "race_condition"
    VALIDATION_BYPASS = "validation_bypass"
    INJECTION = "injection"
    PROTOCOL_ABUSE = "protocol_abuse"
    STATE_MANIPULATION = "state_manipulation"
    TIMING_ATTACK = "timing_attack"
    MEMORY_CORRUPTION = "memory_corruption"
    CRYPTO_WEAKNESS = "crypto_weakness"
    HOOK_POINT = "hook_point"
    NETWORK_EXPLOIT = "network_exploit"
    CLIENT_SIDE_ONLY = "client_side_only"

class Severity(Enum):
    CRITICAL = "critical"  # Game-breaking, easy to exploit
    HIGH = "high"          # Significant advantage
    MEDIUM = "medium"      # Moderate advantage
    LOW = "low"            # Minor advantage

@dataclass
class Exploit:
    name: str
    category: ExploitCategory
    severity: Severity
    description: str
    location: str  # File and line
    code_pattern: str
    exploit_method: str
    requirements: List[str]
    detection_risk: str
    proof_of_concept: str
    cross_references: List[str] = field(default_factory=list)

# RAG Query patterns for exploit discovery
EXPLOIT_QUERIES = {
    # Integer Overflow/Underflow
    "overflow": [
        "int uint Number * + - multiply add subtract overflow",
        "troop num amount count * cost food gold",
        "INT32_MAX MAX_VALUE overflow wrap negative",
        "resource amount increaseRate calculation",
    ],
    
    # Race Conditions
    "race": [
        "timer setTimeout setInterval async callback",
        "addEventListener dispatch event sequence",
        "queue pending status concurrent parallel",
        "lock mutex synchronize atomic",
    ],
    
    # Validation Bypass
    "validation": [
        "if check validate verify requirement",
        "bVisitor isValid canDo permission",
        "null undefined NaN empty zero",
        "client-side only local check",
    ],
    
    # Protocol Abuse
    "protocol": [
        "sendMessage cmd params sequence",
        "ResponseDispatcher handler callback",
        "Socket connect send receive packet",
        "AMF serialize deserialize encode decode",
    ],
    
    # State Manipulation  
    "state": [
        "Context getInstance singleton state",
        "status flag boolean toggle switch",
        "SharedObject LocalStorage persist",
        "session token cookie store",
    ],
    
    # Timing Attacks
    "timing": [
        "cooldown timer delay wait sleep",
        "startTime endTime duration interval",
        "speed rate frequency throttle",
        "serverTime clientTime sync adjust",
    ],
    
    # Crypto Weaknesses
    "crypto": [
        "encrypt decrypt hash MD5 XOR",
        "key salt secret password token",
        "signature verify sign HMAC",
        "random seed generate predictable",
    ],
    
    # Hook Points
    "hooks": [
        "ExternalInterface call addCallback",
        "eval Function new execute",
        "getDefinitionByName describeType reflect",
        "dynamic * Object bracket access",
    ],
    
    # Network Exploits
    "network": [
        "Socket URLLoader URLRequest connect",
        "proxy intercept modify inject",
        "replay duplicate resend packet",
        "sequence order timing flood",
    ],
}

# Known exploit patterns with proof
KNOWN_EXPLOITS = [
    Exploit(
        name="Integer Overflow Troop Training",
        category=ExploitCategory.INTEGER_OVERFLOW,
        severity=Severity.CRITICAL,
        description="Training massive troops causes integer overflow, resulting in free/negative cost",
        location="com/evony/client/action/TroopCommands.as",
        code_pattern="num * cost > INT32_MAX",
        exploit_method="""
1. Calculate overflow threshold: INT32_MAX / troop_food_cost + 1
2. Train that exact number of troops
3. Cost wraps to negative, giving free troops or resources

Thresholds:
- Archer (350 food): 6,135,037 troops
- Worker (50 food): 42,949,673 troops  
- Catapult (3000 food): 715,828 troops
""",
        requirements=["Sufficient barracks capacity", "Population available"],
        detection_risk="LOW - Server may not validate overflow",
        proof_of_concept="train a:6135037",
        cross_references=["food_flip", "resource_overflow"]
    ),
    
    Exploit(
        name="Food Flip Glitch",
        category=ExploitCategory.INTEGER_OVERFLOW,
        severity=Severity.CRITICAL,
        description="Negative food consumption flips to massive positive",
        location="com/evony/Context.as:timerHandler",
        code_pattern="food.amount = base + (increaseRate - troopCostFood)",
        exploit_method="""
1. Build massive army to increase troopCostFood
2. Let food go negative (overflow)
3. Negative value wraps to INT32_MAX
4. Instant billions of food
""",
        requirements=["Large army", "Low food production"],
        detection_risk="MEDIUM - Abnormal resource values",
        proof_of_concept="Build 10M+ archers, wait for food tick",
        cross_references=["troop_overflow", "resource_calc"]
    ),
    
    Exploit(
        name="Race Condition Item Duplication",
        category=ExploitCategory.RACE_CONDITION,
        severity=Severity.HIGH,
        description="Rapid item use before server confirms consumption",
        location="com/evony/client/action/ItemCommands.as",
        code_pattern="sendMessage before wait for response",
        exploit_method="""
1. Send item.useItem command
2. Immediately send again before response
3. Client allows both, server may process both
4. Item duplicated or effect stacked
""",
        requirements=["Fast connection", "Timing precision"],
        detection_risk="MEDIUM - Rapid duplicate requests",
        proof_of_concept="Rapid-fire useItem with same itemId",
        cross_references=["packet_replay", "command_flood"]
    ),
    
    Exploit(
        name="Client-Side Validation Only",
        category=ExploitCategory.VALIDATION_BYPASS,
        severity=Severity.HIGH,
        description="Many checks only exist on client, server trusts client",
        location="com/evony/SenderImpl.as",
        code_pattern="if (bVisitor || getCurCastle() == null) return",
        exploit_method="""
1. Intercept sendMessage calls
2. Bypass client-side checks
3. Send commands that client would block
4. Server may accept without validation

Bypassable checks:
- Visitor restrictions
- Resource requirements
- Cooldown timers
- Building requirements
""",
        requirements=["Packet interception tool", "Protocol knowledge"],
        detection_risk="LOW - Server often trusts client",
        proof_of_concept="Send upgrade command without resources",
        cross_references=["packet_injection", "proxy_modify"]
    ),
    
    Exploit(
        name="Negative Resource Transfer",
        category=ExploitCategory.VALIDATION_BYPASS,
        severity=Severity.HIGH,
        description="Sending negative resources in transport gives to sender",
        location="army.newArmy params",
        code_pattern="resource string not validated for negative",
        exploit_method="""
1. Create transport army
2. Set resource values as negative: "-1000000,-1000000,..."
3. Server may interpret as giving resources TO you
4. Drain target's resources
""",
        requirements=["Target coordinates", "Transport capability"],
        detection_risk="MEDIUM - Unusual resource values",
        proof_of_concept="transport 100,200 r:-1000000,-1000000,0,0,0",
        cross_references=["parameter_injection", "type_confusion"]
    ),
    
    Exploit(
        name="Session Replay Attack",
        category=ExploitCategory.NETWORK_EXPLOIT,
        severity=Severity.MEDIUM,
        description="Captured packets can be replayed",
        location="Network layer",
        code_pattern="No nonce/timestamp validation",
        exploit_method="""
1. Capture successful command packet
2. Save packet bytes
3. Replay same packet later
4. Action repeats if server doesn't track

Best targets:
- Resource collection
- Item usage
- Troop training
""",
        requirements=["Packet capture tool", "Understanding of AMF"],
        detection_risk="LOW - Identical packets common",
        proof_of_concept="Capture train command, replay 10x",
        cross_references=["packet_capture", "amf_decode"]
    ),
    
    Exploit(
        name="Timer Manipulation",
        category=ExploitCategory.TIMING_ATTACK,
        severity=Severity.MEDIUM,
        description="Client-side timers can be manipulated",
        location="com/evony/Context.as:timerHandler",
        code_pattern="timer.start() with local time",
        exploit_method="""
1. Hook Flash timer functions
2. Accelerate timer callbacks
3. Client thinks more time passed
4. Cooldowns expire faster locally

Affects:
- Building queue display
- March time estimates
- Resource accumulation display
""",
        requirements=["Flash debugging tools", "Memory editing"],
        detection_risk="LOW - Only affects display",
        proof_of_concept="CheatEngine to speed up timer",
        cross_references=["memory_edit", "client_hook"]
    ),
    
    Exploit(
        name="Weak XOR Encryption",
        category=ExploitCategory.CRYPTO_WEAKNESS,
        severity=Severity.MEDIUM,
        description="XOR with single byte key is trivially reversible",
        location="Protocol encryption layer",
        code_pattern="data XOR 0xAA",
        exploit_method="""
1. Capture encrypted packet
2. XOR all bytes with 0xAA
3. Plaintext revealed
4. Modify and re-encrypt

Key: 0xAA (170 decimal)
""",
        requirements=["Packet capture"],
        detection_risk="NONE - Just reading",
        proof_of_concept="bytes([b ^ 0xAA for b in packet])",
        cross_references=["packet_decode", "crypto_keys"]
    ),
    
    Exploit(
        name="Predictable Request Signature",
        category=ExploitCategory.CRYPTO_WEAKNESS,
        severity=Severity.HIGH,
        description="MD5 signature uses known static key",
        location="Request signing",
        code_pattern="MD5(params + ACTION_KEY)",
        exploit_method="""
1. Know ACTION_KEY (extracted)
2. Construct any params string
3. Calculate MD5(params + ACTION_KEY)
4. Send with valid signature

ACTION_KEY: "TAO_{313-894*&*($*#-FDIU(430}-{facebook_dioe(&*%$l}"
""",
        requirements=["ACTION_KEY (known)"],
        detection_risk="NONE - Valid signatures",
        proof_of_concept="hashlib.md5(params + ACTION_KEY).hexdigest()",
        cross_references=["request_forge", "key_extraction"]
    ),
    
    Exploit(
        name="Dynamic Object Injection",
        category=ExploitCategory.INJECTION,
        severity=Severity.HIGH,
        description="Dynamic AS3 objects allow property injection",
        location="AMF deserialization",
        code_pattern="obj[prop] = value with dynamic class",
        exploit_method="""
1. Craft AMF response with extra properties
2. Dynamic objects accept any property
3. Inject unexpected values
4. May override internal state

Targets:
- PlayerBean
- CastleBean
- TroopBean (add fake troops)
""",
        requirements=["AMF crafting capability", "MITM position"],
        detection_risk="MEDIUM - Unusual properties",
        proof_of_concept="Add 'gold.amount': 999999999 to response",
        cross_references=["amf_craft", "response_inject"]
    ),
    
    Exploit(
        name="ExternalInterface Hook",
        category=ExploitCategory.HOOK_POINT,
        severity=Severity.HIGH,
        description="Flash ExternalInterface allows JavaScript injection",
        location="ExternalInterface.call usage",
        code_pattern="ExternalInterface.addCallback",
        exploit_method="""
1. Load game in controlled browser
2. Override ExternalInterface callbacks
3. Intercept all Flash-JS communication
4. Modify data in transit

Hookable functions found in client.
""",
        requirements=["Browser control", "JavaScript access"],
        detection_risk="LOW - Client-side only",
        proof_of_concept="Override window.__flash__* functions",
        cross_references=["js_bridge", "browser_hook"]
    ),
]

class RAGExploitScanner:
    """Scans codebase using RAG for exploit opportunities"""
    
    def __init__(self):
        self.results: List[Exploit] = []
        self.rag = None
        self._init_rag()
    
    def _init_rag(self):
        """Initialize RAG connection"""
        try:
            from evony_rag.rag_v2 import EvonyRAGv2
            self.rag = EvonyRAGv2()
            self.rag.policy.set_mode("full_access")
            print("[+] RAG initialized in full_access mode")
        except ImportError:
            print("[!] RAG not available, using pattern matching only")
            self.rag = None
    
    def scan_all(self) -> List[Exploit]:
        """Run all exploit scans"""
        print("\n" + "="*60)
        print(" RAG EXPLOIT SCANNER - COMPREHENSIVE VULNERABILITY DISCOVERY")
        print("="*60 + "\n")
        
        # Start with known exploits
        self.results.extend(KNOWN_EXPLOITS)
        print(f"[+] Loaded {len(KNOWN_EXPLOITS)} known exploits")
        
        if self.rag:
            # Run RAG-based discovery
            self._scan_integer_overflows()
            self._scan_race_conditions()
            self._scan_validation_bypasses()
            self._scan_protocol_abuse()
            self._scan_state_manipulation()
            self._scan_timing_attacks()
            self._scan_crypto_weaknesses()
            self._scan_hook_points()
            self._scan_network_exploits()
        
        # Cross-reference findings
        self._cross_reference_exploits()
        
        return self.results
    
    def _rag_search(self, query: str, k: int = 10) -> List[Dict]:
        """Search RAG for patterns"""
        if not self.rag:
            return []
        try:
            results = self.rag.search_only(query, k=k)
            return [{"file": r.file, "snippet": r.snippet, "score": r.score} 
                    for r in results]
        except Exception as e:
            print(f"[!] RAG search error: {e}")
            return []
    
    def _scan_integer_overflows(self):
        """Find integer overflow vulnerabilities"""
        print("\n[*] Scanning for INTEGER OVERFLOW vulnerabilities...")
        
        queries = EXPLOIT_QUERIES["overflow"]
        for query in queries:
            results = self._rag_search(query, k=15)
            for r in results:
                # Check for multiplication patterns
                if any(p in r["snippet"].lower() for p in ["* cost", "* num", "amount *", "count *"]):
                    self._add_potential_exploit(
                        name=f"Potential Overflow in {r['file']}",
                        category=ExploitCategory.INTEGER_OVERFLOW,
                        severity=Severity.HIGH,
                        description="Multiplication without overflow check",
                        location=r["file"],
                        snippet=r["snippet"]
                    )
    
    def _scan_race_conditions(self):
        """Find race condition vulnerabilities"""
        print("[*] Scanning for RACE CONDITION vulnerabilities...")
        
        queries = EXPLOIT_QUERIES["race"]
        for query in queries:
            results = self._rag_search(query, k=15)
            for r in results:
                if any(p in r["snippet"].lower() for p in ["timer", "settimeout", "async", "callback"]):
                    self._add_potential_exploit(
                        name=f"Potential Race in {r['file']}",
                        category=ExploitCategory.RACE_CONDITION,
                        severity=Severity.MEDIUM,
                        description="Async operation without synchronization",
                        location=r["file"],
                        snippet=r["snippet"]
                    )
    
    def _scan_validation_bypasses(self):
        """Find validation bypass vulnerabilities"""
        print("[*] Scanning for VALIDATION BYPASS vulnerabilities...")
        
        queries = EXPLOIT_QUERIES["validation"]
        for query in queries:
            results = self._rag_search(query, k=15)
            for r in results:
                if any(p in r["snippet"].lower() for p in ["if (", "check", "valid", "require"]):
                    self._add_potential_exploit(
                        name=f"Potential Bypass in {r['file']}",
                        category=ExploitCategory.VALIDATION_BYPASS,
                        severity=Severity.MEDIUM,
                        description="Client-side validation only",
                        location=r["file"],
                        snippet=r["snippet"]
                    )
    
    def _scan_protocol_abuse(self):
        """Find protocol abuse vulnerabilities"""
        print("[*] Scanning for PROTOCOL ABUSE vulnerabilities...")
        
        queries = EXPLOIT_QUERIES["protocol"]
        for query in queries:
            results = self._rag_search(query, k=15)
            for r in results:
                if any(p in r["snippet"].lower() for p in ["sendmessage", "cmd", "socket", "amf"]):
                    self._add_potential_exploit(
                        name=f"Protocol Point in {r['file']}",
                        category=ExploitCategory.PROTOCOL_ABUSE,
                        severity=Severity.HIGH,
                        description="Command injection point",
                        location=r["file"],
                        snippet=r["snippet"]
                    )
    
    def _scan_state_manipulation(self):
        """Find state manipulation vulnerabilities"""
        print("[*] Scanning for STATE MANIPULATION vulnerabilities...")
        
        queries = EXPLOIT_QUERIES["state"]
        for query in queries:
            results = self._rag_search(query, k=15)
            for r in results:
                if any(p in r["snippet"].lower() for p in ["context", "singleton", "state", "sharedobject"]):
                    self._add_potential_exploit(
                        name=f"State Point in {r['file']}",
                        category=ExploitCategory.STATE_MANIPULATION,
                        severity=Severity.MEDIUM,
                        description="Modifiable game state",
                        location=r["file"],
                        snippet=r["snippet"]
                    )
    
    def _scan_timing_attacks(self):
        """Find timing attack vulnerabilities"""
        print("[*] Scanning for TIMING ATTACK vulnerabilities...")
        
        queries = EXPLOIT_QUERIES["timing"]
        for query in queries:
            results = self._rag_search(query, k=15)
            for r in results:
                if any(p in r["snippet"].lower() for p in ["cooldown", "timer", "delay", "servertime"]):
                    self._add_potential_exploit(
                        name=f"Timing Point in {r['file']}",
                        category=ExploitCategory.TIMING_ATTACK,
                        severity=Severity.LOW,
                        description="Time-based logic exploitable",
                        location=r["file"],
                        snippet=r["snippet"]
                    )
    
    def _scan_crypto_weaknesses(self):
        """Find cryptographic weaknesses"""
        print("[*] Scanning for CRYPTO WEAKNESS vulnerabilities...")
        
        queries = EXPLOIT_QUERIES["crypto"]
        for query in queries:
            results = self._rag_search(query, k=15)
            for r in results:
                if any(p in r["snippet"].lower() for p in ["md5", "xor", "encrypt", "key", "hash"]):
                    self._add_potential_exploit(
                        name=f"Crypto Weakness in {r['file']}",
                        category=ExploitCategory.CRYPTO_WEAKNESS,
                        severity=Severity.HIGH,
                        description="Weak cryptographic implementation",
                        location=r["file"],
                        snippet=r["snippet"]
                    )
    
    def _scan_hook_points(self):
        """Find hook points for injection"""
        print("[*] Scanning for HOOK POINT vulnerabilities...")
        
        queries = EXPLOIT_QUERIES["hooks"]
        for query in queries:
            results = self._rag_search(query, k=15)
            for r in results:
                if any(p in r["snippet"].lower() for p in ["externalinterface", "eval", "getdefinitionbyname", "dynamic"]):
                    self._add_potential_exploit(
                        name=f"Hook Point in {r['file']}",
                        category=ExploitCategory.HOOK_POINT,
                        severity=Severity.HIGH,
                        description="Code injection point",
                        location=r["file"],
                        snippet=r["snippet"]
                    )
    
    def _scan_network_exploits(self):
        """Find network-level vulnerabilities"""
        print("[*] Scanning for NETWORK EXPLOIT vulnerabilities...")
        
        queries = EXPLOIT_QUERIES["network"]
        for query in queries:
            results = self._rag_search(query, k=15)
            for r in results:
                if any(p in r["snippet"].lower() for p in ["socket", "urlloader", "connect", "send"]):
                    self._add_potential_exploit(
                        name=f"Network Point in {r['file']}",
                        category=ExploitCategory.NETWORK_EXPLOIT,
                        severity=Severity.HIGH,
                        description="Network interception point",
                        location=r["file"],
                        snippet=r["snippet"]
                    )
    
    def _add_potential_exploit(self, name: str, category: ExploitCategory, 
                               severity: Severity, description: str,
                               location: str, snippet: str):
        """Add a potential exploit finding"""
        # Avoid duplicates
        for existing in self.results:
            if existing.location == location and existing.category == category:
                return
        
        exploit = Exploit(
            name=name,
            category=category,
            severity=severity,
            description=description,
            location=location,
            code_pattern=snippet[:200],
            exploit_method="Requires further analysis",
            requirements=["Manual verification needed"],
            detection_risk="UNKNOWN",
            proof_of_concept="TODO: Develop PoC"
        )
        self.results.append(exploit)
    
    def _cross_reference_exploits(self):
        """Find exploits that work across multiple areas"""
        print("\n[*] Cross-referencing exploits...")
        
        # Group by category
        by_category = {}
        for exploit in self.results:
            cat = exploit.category.value
            if cat not in by_category:
                by_category[cat] = []
            by_category[cat].append(exploit)
        
        # Find patterns that appear in multiple files
        for cat, exploits in by_category.items():
            if len(exploits) > 1:
                for i, e1 in enumerate(exploits):
                    for e2 in exploits[i+1:]:
                        if e1.location != e2.location:
                            e1.cross_references.append(e2.location)
                            e2.cross_references.append(e1.location)
    
    def generate_report(self) -> str:
        """Generate markdown report of findings"""
        report = []
        report.append("# ðŸŽ¯ EXPLOIT SCANNER RESULTS\n")
        report.append(f"**Scan Time:** {datetime.now().isoformat()}\n")
        report.append(f"**Total Findings:** {len(self.results)}\n")
        
        # Summary by category
        report.append("\n## Summary by Category\n")
        by_cat = {}
        for e in self.results:
            cat = e.category.value
            by_cat[cat] = by_cat.get(cat, 0) + 1
        
        for cat, count in sorted(by_cat.items(), key=lambda x: -x[1]):
            report.append(f"- **{cat}**: {count} findings\n")
        
        # Summary by severity
        report.append("\n## Summary by Severity\n")
        by_sev = {}
        for e in self.results:
            sev = e.severity.value
            by_sev[sev] = by_sev.get(sev, 0) + 1
        
        for sev in ["critical", "high", "medium", "low"]:
            count = by_sev.get(sev, 0)
            report.append(f"- **{sev.upper()}**: {count}\n")
        
        # Critical exploits first
        report.append("\n---\n")
        report.append("\n## ðŸ”´ CRITICAL Exploits\n")
        for e in self.results:
            if e.severity == Severity.CRITICAL:
                report.append(self._format_exploit(e))
        
        report.append("\n## ðŸŸ  HIGH Severity Exploits\n")
        for e in self.results:
            if e.severity == Severity.HIGH:
                report.append(self._format_exploit(e))
        
        report.append("\n## ðŸŸ¡ MEDIUM Severity Exploits\n")
        for e in self.results:
            if e.severity == Severity.MEDIUM:
                report.append(self._format_exploit(e))
        
        report.append("\n## ðŸŸ¢ LOW Severity Exploits\n")
        for e in self.results:
            if e.severity == Severity.LOW:
                report.append(self._format_exploit(e))
        
        return "".join(report)
    
    def _format_exploit(self, e: Exploit) -> str:
        """Format single exploit for report"""
        lines = []
        lines.append(f"\n### {e.name}\n")
        lines.append(f"**Category:** {e.category.value}\n")
        lines.append(f"**Location:** `{e.location}`\n")
        lines.append(f"**Detection Risk:** {e.detection_risk}\n\n")
        lines.append(f"**Description:**\n{e.description}\n\n")
        lines.append(f"**Code Pattern:**\n```\n{e.code_pattern}\n```\n\n")
        lines.append(f"**Exploit Method:**\n{e.exploit_method}\n\n")
        lines.append(f"**Requirements:**\n")
        for req in e.requirements:
            lines.append(f"- {req}\n")
        lines.append(f"\n**Proof of Concept:**\n```\n{e.proof_of_concept}\n```\n")
        
        if e.cross_references:
            lines.append(f"\n**Cross-References:**\n")
            for ref in e.cross_references[:5]:
                lines.append(f"- `{ref}`\n")
        
        return "".join(lines)


def main():
    scanner = RAGExploitScanner()
    exploits = scanner.scan_all()
    
    print(f"\n[+] Found {len(exploits)} total exploit opportunities")
    
    # Generate report
    report = scanner.generate_report()
    
    # Save report
    output_path = Path(__file__).parent / "EXPLOIT_SCAN_RESULTS.md"
    output_path.write_text(report, encoding="utf-8")
    print(f"[+] Report saved to: {output_path}")
    
    # Also save as JSON for processing
    json_path = Path(__file__).parent / "exploits.json"
    json_data = []
    for e in exploits:
        json_data.append({
            "name": e.name,
            "category": e.category.value,
            "severity": e.severity.value,
            "description": e.description,
            "location": e.location,
            "code_pattern": e.code_pattern,
            "exploit_method": e.exploit_method,
            "requirements": e.requirements,
            "detection_risk": e.detection_risk,
            "proof_of_concept": e.proof_of_concept,
            "cross_references": e.cross_references,
        })
    json_path.write_text(json.dumps(json_data, indent=2), encoding="utf-8")
    print(f"[+] JSON data saved to: {json_path}")
    
    return exploits


if __name__ == "__main__":
    main()
