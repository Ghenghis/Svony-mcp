#!/usr/bin/env python3
"""
Validation Bypass Finder - Discovers all client-side validation that can be bypassed
Finds checks that only exist on client, not enforced by server
"""

import sys
import json
from pathlib import Path
from dataclasses import dataclass
from typing import List, Dict
from enum import Enum

sys.path.insert(0, str(Path(__file__).parent.parent))

class BypassType(Enum):
    RESOURCE_CHECK = "resource_check"
    REQUIREMENT_CHECK = "requirement_check"
    PERMISSION_CHECK = "permission_check"
    COOLDOWN_CHECK = "cooldown_check"
    LIMIT_CHECK = "limit_check"
    STATE_CHECK = "state_check"
    INPUT_VALIDATION = "input_validation"

@dataclass
class ValidationBypass:
    name: str
    bypass_type: BypassType
    location: str
    validation_code: str
    bypass_method: str
    server_enforced: str  # YES/NO/PARTIAL/UNKNOWN
    exploit_potential: str

# All known client-side validations that may be bypassable
CLIENT_VALIDATIONS = [
    # RESOURCE CHECKS
    ValidationBypass(
        name="Troop Training Resource Check",
        bypass_type=BypassType.RESOURCE_CHECK,
        location="Client UI / TroopCommands",
        validation_code="""
// Client checks before sending
if (gold < cost.gold || food < cost.food) {
    showError("Not enough resources");
    return; // Never sends to server
}
""",
        bypass_method="""
1. Intercept sendMessage call
2. Bypass client-side resource check
3. Send troop.produceTroop directly
4. Server may not validate resource availability

AutoEvony bypass:
- Bot sends commands directly without client checks
- train a:1000000 - sends even if no resources
""",
        server_enforced="PARTIAL - Server checks but may have bugs",
        exploit_potential="HIGH - May train without resources"
    ),
    
    ValidationBypass(
        name="Building Upgrade Resource Check",
        bypass_type=BypassType.RESOURCE_CHECK,
        location="BuildingUpgradeDialog",
        validation_code="""
if (!hasEnoughResources(building, nextLevel)) {
    upgradeButton.enabled = false;
}
""",
        bypass_method="""
1. Enable button via memory edit
2. Or send castle.upgradeBuilding directly
3. Bypass client resource validation
""",
        server_enforced="LIKELY YES",
        exploit_potential="MEDIUM"
    ),
    
    ValidationBypass(
        name="Research Cost Check",
        bypass_type=BypassType.RESOURCE_CHECK,
        location="ResearchDialog",
        validation_code="""
if (resources < researchCost) {
    return; // Can't research
}
""",
        bypass_method="Send tech.research directly via packet",
        server_enforced="LIKELY YES",
        exploit_potential="MEDIUM"
    ),
    
    # REQUIREMENT CHECKS
    ValidationBypass(
        name="Building Level Requirement",
        bypass_type=BypassType.REQUIREMENT_CHECK,
        location="BuildingCommands",
        validation_code="""
// Check townhall level before upgrade
if (townhallLevel < requiredLevel) {
    showError("Upgrade Townhall first");
    return;
}
""",
        bypass_method="""
1. Send upgrade command directly
2. Skip client-side requirement check
3. Server may not fully validate
""",
        server_enforced="LIKELY YES",
        exploit_potential="LOW"
    ),
    
    ValidationBypass(
        name="Research Prerequisite Check",
        bypass_type=BypassType.REQUIREMENT_CHECK,
        location="TechCommands",
        validation_code="""
if (!hasPrerequisiteResearch(techId)) {
    return; // Can't research
}
""",
        bypass_method="Send tech.research with any techId",
        server_enforced="LIKELY YES",
        exploit_potential="LOW"
    ),
    
    ValidationBypass(
        name="Troop Training Building Check",
        bypass_type=BypassType.REQUIREMENT_CHECK,
        location="TroopCommands",
        validation_code="""
// Check barracks level for troop type
if (barracksLevel < troopRequirement[troopType]) {
    return;
}
""",
        bypass_method="Send train command for any troop type",
        server_enforced="UNKNOWN",
        exploit_potential="MEDIUM"
    ),
    
    # PERMISSION CHECKS
    ValidationBypass(
        name="Visitor Mode Check",
        bypass_type=BypassType.PERMISSION_CHECK,
        location="SenderImpl.as",
        validation_code="""
public function sendMessage(cmd:String, params:Object):void {
    if (bVisitor) {
        return; // Visitors can't send commands
    }
    // ... send
}
""",
        bypass_method="""
1. AutoEvony doesn't check bVisitor
2. Send commands even as visitor
3. Server may not validate visitor status
""",
        server_enforced="LIKELY YES",
        exploit_potential="LOW"
    ),
    
    ValidationBypass(
        name="Castle Ownership Check",
        bypass_type=BypassType.PERMISSION_CHECK,
        location="Various commands",
        validation_code="""
if (castleId != myCastle.id) {
    return; // Not my castle
}
""",
        bypass_method="""
1. Send command with any castleId
2. Try to control other players' castles
""",
        server_enforced="YES - Critical security",
        exploit_potential="LOW - Server validates"
    ),
    
    ValidationBypass(
        name="Hero Ownership Check",
        bypass_type=BypassType.PERMISSION_CHECK,
        location="HeroCommands",
        validation_code="""
if (!isMyHero(heroId)) {
    return;
}
""",
        bypass_method="Send hero commands with any heroId",
        server_enforced="YES",
        exploit_potential="LOW"
    ),
    
    # COOLDOWN CHECKS
    ValidationBypass(
        name="Tax Cooldown Check",
        bypass_type=BypassType.COOLDOWN_CHECK,
        location="InteriorCommands",
        validation_code="""
if (lastTaxTime + COOLDOWN > now) {
    showError("Tax on cooldown");
    return;
}
""",
        bypass_method="""
1. Send interior.taxRate directly
2. Bypass client cooldown timer
3. Server tracks real cooldown

AutoEvony: Can send anytime, server enforces
""",
        server_enforced="YES - Server tracks time",
        exploit_potential="LOW"
    ),
    
    ValidationBypass(
        name="Building Speed-up Cooldown",
        bypass_type=BypassType.COOLDOWN_CHECK,
        location="BuildingCommands",
        validation_code="""
if (speedupUsedRecently) {
    return;
}
""",
        bypass_method="Send speed-up item use rapidly",
        server_enforced="PARTIAL",
        exploit_potential="MEDIUM"
    ),
    
    ValidationBypass(
        name="Attack Cooldown Check",
        bypass_type=BypassType.COOLDOWN_CHECK,
        location="ArmyCommands",
        validation_code="""
// Client may track attack frequency
if (recentAttacks > MAX_ATTACKS_PER_MINUTE) {
    return;
}
""",
        bypass_method="Send army.newArmy without delay",
        server_enforced="PARTIAL - Rate limits exist",
        exploit_potential="MEDIUM"
    ),
    
    # LIMIT CHECKS
    ValidationBypass(
        name="Army Limit Check",
        bypass_type=BypassType.LIMIT_CHECK,
        location="ArmyCommands",
        validation_code="""
if (activeArmies >= MAX_ARMIES) {
    showError("Max armies deployed");
    return;
}
""",
        bypass_method="""
1. Send army.newArmy rapidly
2. Before server updates army count
3. May exceed army limit
""",
        server_enforced="YES but race possible",
        exploit_potential="MEDIUM - Race condition"
    ),
    
    ValidationBypass(
        name="Building Queue Limit",
        bypass_type=BypassType.LIMIT_CHECK,
        location="BuildingCommands",
        validation_code="""
if (buildingQueue.length >= MAX_QUEUE) {
    return;
}
""",
        bypass_method="Send upgrade commands rapidly",
        server_enforced="YES",
        exploit_potential="LOW"
    ),
    
    ValidationBypass(
        name="Troop Count Limit",
        bypass_type=BypassType.LIMIT_CHECK,
        location="TroopCommands",
        validation_code="""
if (num > availablePopulation) {
    num = availablePopulation; // Clamp
}
""",
        bypass_method="""
1. Send train with any num value
2. Client clamps, but direct send doesn't
3. Server may accept any value
""",
        server_enforced="PARTIAL - Overflow possible",
        exploit_potential="HIGH - Integer overflow"
    ),
    
    # STATE CHECKS
    ValidationBypass(
        name="Hero Status Check",
        bypass_type=BypassType.STATE_CHECK,
        location="HeroCommands",
        validation_code="""
if (hero.status != "idle") {
    return; // Hero busy
}
""",
        bypass_method="""
1. Send command for busy hero
2. Client blocks, direct doesn't
3. Server should validate
""",
        server_enforced="YES",
        exploit_potential="LOW"
    ),
    
    ValidationBypass(
        name="Building Status Check",
        bypass_type=BypassType.STATE_CHECK,
        location="BuildingCommands",
        validation_code="""
if (building.status == UPGRADING) {
    return; // Already upgrading
}
""",
        bypass_method="Send upgrade for already upgrading building",
        server_enforced="YES",
        exploit_potential="LOW"
    ),
    
    ValidationBypass(
        name="March Status Check",
        bypass_type=BypassType.STATE_CHECK,
        location="ArmyCommands",
        validation_code="""
// Can't recall completed march
if (army.status == COMPLETED) {
    return;
}
""",
        bypass_method="Send recall for any army state",
        server_enforced="UNKNOWN",
        exploit_potential="MEDIUM"
    ),
    
    # INPUT VALIDATION
    ValidationBypass(
        name="Coordinate Range Check",
        bypass_type=BypassType.INPUT_VALIDATION,
        location="ArmyCommands",
        validation_code="""
if (x < 0 || x > 799 || y < 0 || y > 799) {
    return; // Invalid coordinates
}
""",
        bypass_method="""
1. Send army.newArmy with out-of-bounds coords
2. Try negative, MAX_INT, etc.
3. May cause server errors
""",
        server_enforced="PARTIAL",
        exploit_potential="MEDIUM - Boundary bugs"
    ),
    
    ValidationBypass(
        name="String Length Check",
        bypass_type=BypassType.INPUT_VALIDATION,
        location="Various",
        validation_code="""
if (name.length > MAX_LENGTH) {
    name = name.substring(0, MAX_LENGTH);
}
""",
        bypass_method="""
1. Send very long strings
2. May cause buffer issues
3. Or storage problems
""",
        server_enforced="UNKNOWN",
        exploit_potential="LOW"
    ),
    
    ValidationBypass(
        name="Numeric Type Check",
        bypass_type=BypassType.INPUT_VALIDATION,
        location="All commands",
        validation_code="""
// Client ensures integers
var num:int = parseInt(input);
""",
        bypass_method="""
1. Send non-integer values
2. Send negative numbers
3. Send MAX_INT values
4. AMF allows any Number
""",
        server_enforced="PARTIAL",
        exploit_potential="HIGH - Type confusion"
    ),
    
    ValidationBypass(
        name="Resource String Parse",
        bypass_type=BypassType.INPUT_VALIDATION,
        location="army.newArmy resource param",
        validation_code="""
// Client formats: "gold,food,wood,stone,iron"
var resourceStr:String = formatResources(resources);
""",
        bypass_method="""
1. Send malformed resource string
2. Include negative values
3. Include extra fields
4. Server parsing may differ
""",
        server_enforced="PARTIAL",
        exploit_potential="HIGH - Negative resources"
    ),
]


class ValidationBypassFinder:
    """Finds all bypassable client-side validations"""
    
    def __init__(self):
        self.bypasses = CLIENT_VALIDATIONS.copy()
        self.rag = None
        self._init_rag()
    
    def _init_rag(self):
        try:
            from evony_rag.rag_v2 import EvonyRAGv2
            self.rag = EvonyRAGv2()
            self.rag.policy.set_mode("full_access")
            print("[+] RAG initialized")
        except:
            print("[!] RAG not available")
    
    def search_validations(self):
        """Use RAG to find more validation code"""
        if not self.rag:
            return
        
        print("\n[*] Searching for validation patterns...")
        
        queries = [
            "if check validate return error",
            "if null undefined empty return",
            "if level < require return",
            "if resource amount < cost return",
        ]
        
        for q in queries:
            try:
                results = self.rag.search_only(q, k=10)
                for r in results:
                    print(f"  Found: {r.file}")
            except:
                pass
    
    def generate_report(self) -> str:
        """Generate validation bypass report"""
        lines = []
        lines.append("# ðŸ”“ VALIDATION BYPASS CATALOG\n\n")
        lines.append(f"**Total Validations Analyzed:** {len(self.bypasses)}\n\n")
        
        # Summary
        by_type = {}
        for b in self.bypasses:
            t = b.bypass_type.value
            by_type[t] = by_type.get(t, 0) + 1
        
        lines.append("## Summary by Type\n")
        for t, count in sorted(by_type.items(), key=lambda x: -x[1]):
            lines.append(f"- **{t}**: {count}\n")
        
        # By server enforcement
        lines.append("\n## By Server Enforcement\n")
        enforcement = {"YES": 0, "NO": 0, "PARTIAL": 0, "UNKNOWN": 0, "LIKELY YES": 0}
        for b in self.bypasses:
            for key in enforcement:
                if key in b.server_enforced:
                    enforcement[key] += 1
                    break
        
        for level, count in enforcement.items():
            lines.append(f"- **{level}**: {count}\n")
        
        lines.append("\n---\n")
        
        # High potential first
        lines.append("\n## ðŸ”´ HIGH Exploit Potential\n")
        for b in self.bypasses:
            if "HIGH" in b.exploit_potential:
                lines.append(self._format_bypass(b))
        
        lines.append("\n## ðŸŸ¡ MEDIUM Exploit Potential\n")
        for b in self.bypasses:
            if "MEDIUM" in b.exploit_potential:
                lines.append(self._format_bypass(b))
        
        lines.append("\n## ðŸŸ¢ LOW Exploit Potential\n")
        for b in self.bypasses:
            if "LOW" in b.exploit_potential:
                lines.append(self._format_bypass(b))
        
        return "".join(lines)
    
    def _format_bypass(self, b: ValidationBypass) -> str:
        return f"""
### {b.name}
**Type:** {b.bypass_type.value}  
**Location:** `{b.location}`  
**Server Enforced:** {b.server_enforced}  
**Exploit Potential:** {b.exploit_potential}

**Client Validation Code:**
```actionscript
{b.validation_code}
```

**Bypass Method:**
{b.bypass_method}

---
"""


def main():
    finder = ValidationBypassFinder()
    finder.search_validations()
    
    print(f"\n[+] Total validations: {len(finder.bypasses)}")
    
    report = finder.generate_report()
    output = Path(__file__).parent / "VALIDATION_BYPASSES.md"
    output.write_text(report, encoding="utf-8")
    print(f"[+] Report saved to: {output}")
    
    # JSON
    json_path = Path(__file__).parent / "validation_bypasses.json"
    data = [{"name": b.name, "type": b.bypass_type.value,
             "server_enforced": b.server_enforced,
             "potential": b.exploit_potential} for b in finder.bypasses]
    json_path.write_text(json.dumps(data, indent=2), encoding="utf-8")
    print(f"[+] JSON saved to: {json_path}")


if __name__ == "__main__":
    main()
