#!/usr/bin/env python3
"""
GAP FILLER SCANNER - Discovers missing reverse engineering data
Uses RAG to find and document gaps in EvonyClient and AutoEvony coverage
"""

import sys
import json
import re
from pathlib import Path
from dataclasses import dataclass, field
from typing import List, Dict, Set, Optional
from datetime import datetime

sys.path.insert(0, str(Path(__file__).parent.parent))

@dataclass
class GapItem:
    category: str
    name: str
    location: str
    description: str
    priority: str  # HIGH, MEDIUM, LOW
    status: str = "NOT_ANALYZED"
    discovered_data: Dict = field(default_factory=dict)

class GapFillerScanner:
    """Scans for and fills gaps in reverse engineering coverage"""
    
    def __init__(self):
        self.rag = None
        self.gaps: List[GapItem] = []
        self.findings: Dict[str, List] = {
            "commands": [],
            "beans": [],
            "handlers": [],
            "enums": [],
            "formulas": [],
            "errors": [],
        }
        self._init_rag()
    
    def _init_rag(self):
        try:
            from evony_rag.rag_v2 import EvonyRAGv2
            self.rag = EvonyRAGv2()
            self.rag.policy.set_mode("full_access")
            print("[+] RAG initialized in full_access mode")
        except Exception as e:
            print(f"[!] RAG init failed: {e}")
    
    def _rag_search(self, query: str, k: int = 20) -> List[Dict]:
        """Search RAG and return results"""
        if not self.rag:
            return []
        try:
            results = self.rag.search_only(query, k=k)
            parsed = []
            for r in results:
                if hasattr(r, 'file'):
                    parsed.append({"file": r.file, "snippet": getattr(r, 'snippet', '')})
                elif isinstance(r, dict):
                    parsed.append(r)
            return parsed
        except Exception as e:
            print(f"    [!] Search error: {e}")
            return []
    
    # =========================================
    # GAP DISCOVERY METHODS
    # =========================================
    
    def discover_undocumented_commands(self):
        """Find commands not fully documented"""
        print("\n[*] Discovering undocumented commands...")
        
        # Search for sendMessage patterns
        queries = [
            "sendMessage cmd params",
            "Commands.as sendMessage",
            "Sender.as send message",
            "ActionFactory getInstance commands",
        ]
        
        all_commands = set()
        for q in queries:
            results = self._rag_search(q, k=30)
            for r in results:
                snippet = r.get("snippet", "")
                # Extract command names
                matches = re.findall(r'sendMessage\s*\(\s*"([^"]+)"', snippet)
                matches += re.findall(r'cmd:\s*"([^"]+)"', snippet)
                matches += re.findall(r'"(\w+\.\w+)"', snippet)
                all_commands.update(matches)
        
        self.findings["commands"] = list(all_commands)
        print(f"    [+] Found {len(all_commands)} unique commands")
        return all_commands
    
    def discover_response_handlers(self):
        """Find all response handlers"""
        print("\n[*] Discovering response handlers...")
        
        queries = [
            "ResponseDispatcher addEventListener",
            "onResponse callback handler",
            "ResponseDispatcher getInstance",
        ]
        
        handlers = set()
        for q in queries:
            results = self._rag_search(q, k=30)
            for r in results:
                snippet = r.get("snippet", "")
                # Extract handler names
                matches = re.findall(r'ResponseDispatcher\.(\w+)', snippet)
                matches += re.findall(r'on(\w+Response)', snippet)
                matches += re.findall(r'addEventListener\s*\(\s*ResponseDispatcher\.(\w+)', snippet)
                handlers.update(matches)
        
        self.findings["handlers"] = list(handlers)
        print(f"    [+] Found {len(handlers)} response handlers")
        return handlers
    
    def discover_bean_fields(self):
        """Find all bean class fields"""
        print("\n[*] Discovering bean fields...")
        
        queries = [
            "Bean public var",
            "extends BaseBean",
            "com.evony.common.beans",
            "Bean this._arg_1",
        ]
        
        beans = {}
        for q in queries:
            results = self._rag_search(q, k=30)
            for r in results:
                file_path = r.get("file", "")
                snippet = r.get("snippet", "")
                
                # Extract bean name from file
                if "Bean" in file_path:
                    bean_name = Path(file_path).stem
                    if bean_name not in beans:
                        beans[bean_name] = {"fields": set(), "file": file_path}
                    
                    # Extract fields
                    field_matches = re.findall(r'public\s+var\s+(\w+)\s*:\s*(\w+)', snippet)
                    for name, type_ in field_matches:
                        beans[bean_name]["fields"].add(f"{name}:{type_}")
        
        self.findings["beans"] = {k: {"fields": list(v["fields"]), "file": v["file"]} 
                                   for k, v in beans.items()}
        print(f"    [+] Found {len(beans)} bean classes")
        return beans
    
    def discover_enums_constants(self):
        """Find all enums and constants"""
        print("\n[*] Discovering enums and constants...")
        
        queries = [
            "public static const",
            "TYPE_ID typeId",
            "enum status state",
            "const int uint Number",
        ]
        
        enums = {}
        for q in queries:
            results = self._rag_search(q, k=30)
            for r in results:
                snippet = r.get("snippet", "")
                file_path = r.get("file", "")
                
                # Extract constants
                const_matches = re.findall(
                    r'public\s+static\s+const\s+(\w+)\s*:\s*\w+\s*=\s*([^;]+)', 
                    snippet
                )
                for name, value in const_matches:
                    key = Path(file_path).stem if file_path else "unknown"
                    if key not in enums:
                        enums[key] = []
                    enums[key].append({"name": name, "value": value.strip()})
        
        self.findings["enums"] = enums
        total = sum(len(v) for v in enums.values())
        print(f"    [+] Found {total} constants in {len(enums)} files")
        return enums
    
    def discover_formulas(self):
        """Find game calculation formulas"""
        print("\n[*] Discovering formulas...")
        
        queries = [
            "calculate formula damage attack",
            "cost food gold resource",
            "speed time distance march",
            "experience level upgrade",
            "production rate increase",
        ]
        
        formulas = []
        for q in queries:
            results = self._rag_search(q, k=20)
            for r in results:
                snippet = r.get("snippet", "")
                file_path = r.get("file", "")
                
                # Look for calculation patterns
                if any(op in snippet for op in ["*", "/", "+", "-", "Math."]):
                    if any(kw in snippet.lower() for kw in ["calculate", "formula", "cost", "damage"]):
                        formulas.append({
                            "file": file_path,
                            "snippet": snippet[:200],
                        })
        
        self.findings["formulas"] = formulas
        print(f"    [+] Found {len(formulas)} potential formulas")
        return formulas
    
    def discover_error_codes(self):
        """Find all error codes and messages"""
        print("\n[*] Discovering error codes...")
        
        queries = [
            "error code errorCode",
            "ok == false error",
            "msg message error fail",
            "CommandResponse ok",
        ]
        
        errors = []
        for q in queries:
            results = self._rag_search(q, k=20)
            for r in results:
                snippet = r.get("snippet", "")
                
                # Look for error patterns
                error_matches = re.findall(r'error[Cc]ode\s*[=:]\s*(\d+)', snippet)
                error_matches += re.findall(r'msg\s*[=:]\s*"([^"]+)"', snippet)
                
                for err in error_matches:
                    errors.append(err)
        
        self.findings["errors"] = list(set(errors))
        print(f"    [+] Found {len(self.findings['errors'])} error codes/messages")
        return errors
    
    def discover_hidden_features(self):
        """Find hidden/debug features"""
        print("\n[*] Discovering hidden features...")
        
        queries = [
            "debug admin hidden",
            "test dev developer",
            "secret cheat bypass",
            "internal private special",
        ]
        
        hidden = []
        for q in queries:
            results = self._rag_search(q, k=15)
            for r in results:
                file_path = r.get("file", "")
                snippet = r.get("snippet", "")
                hidden.append({
                    "file": file_path,
                    "snippet": snippet[:150],
                })
        
        print(f"    [+] Found {len(hidden)} potential hidden features")
        return hidden
    
    def discover_validation_rules(self):
        """Find client-side validation rules"""
        print("\n[*] Discovering validation rules...")
        
        queries = [
            "if check validate verify",
            "isValid canDo permission",
            "require minimum maximum",
            "limit threshold boundary",
        ]
        
        validations = []
        for q in queries:
            results = self._rag_search(q, k=20)
            for r in results:
                snippet = r.get("snippet", "")
                file_path = r.get("file", "")
                
                # Look for validation patterns
                if any(kw in snippet.lower() for kw in ["if", "check", "valid", "require"]):
                    validations.append({
                        "file": file_path,
                        "snippet": snippet[:200],
                    })
        
        print(f"    [+] Found {len(validations)} validation rules")
        return validations
    
    # =========================================
    # MAIN SCAN
    # =========================================
    
    def run_full_scan(self):
        """Run complete gap discovery scan"""
        print("\n" + "="*70)
        print(" GAP FILLER SCANNER - Complete Reverse Engineering Analysis")
        print("="*70)
        
        # Run all discovery methods
        commands = self.discover_undocumented_commands()
        handlers = self.discover_response_handlers()
        beans = self.discover_bean_fields()
        enums = self.discover_enums_constants()
        formulas = self.discover_formulas()
        errors = self.discover_error_codes()
        hidden = self.discover_hidden_features()
        validations = self.discover_validation_rules()
        
        # Summary
        print("\n" + "="*70)
        print(" DISCOVERY SUMMARY")
        print("="*70)
        print(f"  Commands found: {len(commands)}")
        print(f"  Response handlers: {len(handlers)}")
        print(f"  Bean classes: {len(beans)}")
        print(f"  Enums/Constants: {sum(len(v) for v in enums.values())}")
        print(f"  Formulas: {len(formulas)}")
        print(f"  Error codes: {len(self.findings['errors'])}")
        print(f"  Hidden features: {len(hidden)}")
        print(f"  Validation rules: {len(validations)}")
        
        return self.findings
    
    def generate_report(self) -> str:
        """Generate comprehensive gap report"""
        lines = []
        
        lines.append("# ðŸ“Š REVERSE ENGINEERING GAP DISCOVERY REPORT\n\n")
        lines.append(f"**Generated:** {datetime.now().isoformat()}\n\n")
        
        # Commands
        lines.append("## Protocol Commands Found\n\n")
        for cmd in sorted(self.findings.get("commands", []))[:50]:
            lines.append(f"- `{cmd}`\n")
        if len(self.findings.get("commands", [])) > 50:
            lines.append(f"- ... and {len(self.findings['commands']) - 50} more\n")
        
        # Response Handlers
        lines.append("\n## Response Handlers Found\n\n")
        for handler in sorted(self.findings.get("handlers", []))[:30]:
            lines.append(f"- `{handler}`\n")
        
        # Beans
        lines.append("\n## Bean Classes Discovered\n\n")
        for bean, data in self.findings.get("beans", {}).items():
            lines.append(f"### {bean}\n")
            lines.append(f"**File:** `{data.get('file', 'unknown')}`\n")
            lines.append("**Fields:**\n")
            for f in list(data.get("fields", []))[:10]:
                lines.append(f"- `{f}`\n")
            lines.append("\n")
        
        # Enums
        lines.append("\n## Constants/Enums Found\n\n")
        for file_name, consts in list(self.findings.get("enums", {}).items())[:10]:
            lines.append(f"### {file_name}\n")
            for c in consts[:5]:
                lines.append(f"- `{c['name']}` = `{c['value']}`\n")
            lines.append("\n")
        
        # Error codes
        lines.append("\n## Error Codes/Messages\n\n")
        for err in self.findings.get("errors", [])[:20]:
            lines.append(f"- `{err}`\n")
        
        return "".join(lines)
    
    def save_findings(self):
        """Save all findings to files"""
        output_dir = Path(__file__).parent
        
        # Save JSON
        json_path = output_dir / "gap_discovery_findings.json"
        # Convert sets to lists for JSON
        json_findings = {}
        for k, v in self.findings.items():
            if isinstance(v, set):
                json_findings[k] = list(v)
            elif isinstance(v, dict):
                json_findings[k] = {
                    str(dk): (list(dv) if isinstance(dv, set) else dv) 
                    for dk, dv in v.items()
                }
            else:
                json_findings[k] = v
        
        json_path.write_text(json.dumps(json_findings, indent=2, default=str), encoding="utf-8")
        print(f"\n[+] JSON saved to: {json_path}")
        
        # Save report
        report = self.generate_report()
        report_path = output_dir / "GAP_DISCOVERY_REPORT.md"
        report_path.write_text(report, encoding="utf-8")
        print(f"[+] Report saved to: {report_path}")


def main():
    scanner = GapFillerScanner()
    scanner.run_full_scan()
    scanner.save_findings()


if __name__ == "__main__":
    main()
