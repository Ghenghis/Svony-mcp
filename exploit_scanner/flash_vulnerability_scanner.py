#!/usr/bin/env python3
"""
Flash Vulnerability Scanner - Comprehensive Flash/AS3 exploit discovery for Evony
Based on research of known Flash CVEs and vulnerabilities

EVONY FLASH VERSION DETECTED:
- Target Player: 27.0
- ActionScript: 3.0
- Flex SDK: 4.x (4.5, 4.6)
- SWF Version: Varies by component
"""

import sys
import json
from pathlib import Path
from dataclasses import dataclass, field
from typing import List, Dict
from enum import Enum
from datetime import datetime

sys.path.insert(0, str(Path(__file__).parent.parent))

class FlashVulnCategory(Enum):
    MEMORY_CORRUPTION = "memory_corruption"      # UAF, heap overflow, etc.
    TYPE_CONFUSION = "type_confusion"            # Object type exploits
    DESERIALIZATION = "deserialization"          # AMF, SharedObject
    INJECTION = "injection"                      # Code/command injection
    BYPASS = "bypass"                            # Security bypass
    INFORMATION_LEAK = "information_leak"        # Memory disclosure
    LOGIC_FLAW = "logic_flaw"                    # Application logic

class Severity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"

@dataclass
class FlashVulnerability:
    cve_id: str
    name: str
    category: FlashVulnCategory
    severity: Severity
    affected_versions: str
    description: str
    as3_pattern: str           # ActionScript pattern to search for
    rag_query: str             # Query to run against RAG
    exploit_method: str
    evony_applicable: str      # How this applies to Evony
    detection_in_code: List[str] = field(default_factory=list)
    mitigation: str = ""

# Comprehensive Flash vulnerabilities applicable to Evony
FLASH_VULNERABILITIES = [
    # MEMORY CORRUPTION
    FlashVulnerability(
        cve_id="CVE-2015-5119",
        name="ByteArray Use-After-Free",
        category=FlashVulnCategory.MEMORY_CORRUPTION,
        severity=Severity.CRITICAL,
        affected_versions="Flash 9.0 - 18.0.0.194",
        description="""
ByteArray class use-after-free vulnerability. When valueOf() is called during
ByteArray assignment, memory can be reallocated while pointer remains.
Allows arbitrary code execution.
""",
        as3_pattern="ByteArray valueOf prototype",
        rag_query="ByteArray valueOf length realloc prototype",
        exploit_method="""
1. Create ByteArray with specific length
2. Override valueOf to resize ByteArray
3. Assign object to ByteArray index
4. valueOf triggers, memory reallocates
5. Original pointer now dangles
6. Spray Vector.<uint> to control memory
7. Corrupt Vector length for R/W primitive
""",
        evony_applicable="""
Evony uses ByteArray extensively for:
- AMF packet serialization/deserialization
- Network data handling
- Binary data processing
Check: GameClient, Socket handlers, AMF processors
""",
        detection_in_code=["ByteArray", "valueOf", "prototype", ".length ="],
        mitigation="Update Flash Player, use Vector length validation"
    ),
    
    FlashVulnerability(
        cve_id="CVE-2015-0311",
        name="domainMemory Use-After-Free",
        category=FlashVulnCategory.MEMORY_CORRUPTION,
        severity=Severity.CRITICAL,
        affected_versions="Flash 16.0 and earlier",
        description="""
Use-after-free in domainMemory/ByteArray interaction.
Memory corruption through worker MessageChannel.
""",
        as3_pattern="domainMemory ApplicationDomain worker",
        rag_query="domainMemory ApplicationDomain MessageChannel worker",
        exploit_method="""
1. Create ByteArray for domainMemory
2. Use worker MessageChannel
3. Trigger memory corruption
4. Gain arbitrary R/W
""",
        evony_applicable="""
Check for ApplicationDomain usage and any worker threads.
Less likely in game client but worth checking.
""",
        detection_in_code=["domainMemory", "ApplicationDomain", "Worker", "MessageChannel"],
        mitigation="Flash Player 16.0.0.296+"
    ),
    
    FlashVulnerability(
        cve_id="CVE-2018-4878",
        name="DRMManager Use-After-Free",
        category=FlashVulnCategory.MEMORY_CORRUPTION,
        severity=Severity.CRITICAL,
        affected_versions="Flash 28.0.0.137 and earlier",
        description="""
Use-after-free in Primetime SDK DRMManager.
Zero-day exploited in wild by APT groups.
""",
        as3_pattern="DRMManager MediaPlayer",
        rag_query="DRMManager MediaPlayer DRM license",
        exploit_method="""
1. Create DRMManager instance
2. Trigger specific callback sequence
3. Memory freed but reference kept
4. Exploit dangling pointer
""",
        evony_applicable="""
Unlikely unless Evony uses DRM for media.
Check for any MediaPlayer or DRM components.
""",
        detection_in_code=["DRMManager", "MediaPlayer", "DRM"],
        mitigation="Flash Player 28.0.0.161+"
    ),
    
    # TYPE CONFUSION
    FlashVulnerability(
        cve_id="CVE-2015-7645",
        name="Type Confusion in Object Handling",
        category=FlashVulnCategory.TYPE_CONFUSION,
        severity=Severity.CRITICAL,
        affected_versions="Flash 19.0.0.207 and earlier",
        description="""
Type confusion when handling certain object types.
Allows memory corruption and code execution.
""",
        as3_pattern="as Object cast dynamic",
        rag_query="dynamic Object cast type conversion",
        exploit_method="""
1. Create objects with mismatched types
2. Force type confusion through casting
3. Access memory at wrong offset
4. Achieve code execution
""",
        evony_applicable="""
Evony uses dynamic typing extensively:
- AMF deserialization creates dynamic objects
- Protocol parsing may have type confusion
- Check all 'as' casts and dynamic classes
""",
        detection_in_code=["dynamic", "as Object", "as *", "getDefinitionByName"],
        mitigation="Strict typing, runtime type checks"
    ),
    
    FlashVulnerability(
        cve_id="CVE-2016-4117",
        name="Type Confusion in Graphics",
        category=FlashVulnCategory.TYPE_CONFUSION,
        severity=Severity.HIGH,
        affected_versions="Flash 21.0.0.226 and earlier",
        description="""
Type confusion in graphics rendering.
Exploitable for code execution.
""",
        as3_pattern="Graphics draw BitmapData",
        rag_query="Graphics BitmapData draw render",
        exploit_method="""
1. Create malformed graphic objects
2. Trigger rendering with type confusion
3. Corrupt memory during draw
""",
        evony_applicable="""
Evony renders many graphics:
- Map tiles, sprites, UI elements
- Check Graphics class usage
""",
        detection_in_code=["Graphics", "BitmapData", "draw", "beginBitmapFill"],
        mitigation="Update Flash, validate graphic data"
    ),
    
    # DESERIALIZATION
    FlashVulnerability(
        cve_id="CVE-2017-3066",
        name="AMF Deserialization RCE",
        category=FlashVulnCategory.DESERIALIZATION,
        severity=Severity.CRITICAL,
        affected_versions="BlazeDS, all AMF libraries",
        description="""
AMF deserialization allows arbitrary object creation.
Server-side vulnerability but pattern exists in client.
Externalizable trait allows Java deserialization chain.
""",
        as3_pattern="AMF registerClassAlias IExternalizable",
        rag_query="AMF deserialize registerClassAlias readExternal",
        exploit_method="""
1. Craft malicious AMF payload
2. Include Externalizable objects
3. Server deserializes, executes code
4. Client can also be vulnerable
""",
        evony_applicable="""
CRITICAL for Evony:
- All communication is AMF
- Check AMF deserialization code
- Look for registerClassAlias
- IExternalizable implementations
""",
        detection_in_code=["registerClassAlias", "IExternalizable", "readExternal", "writeExternal", "AMF"],
        mitigation="Whitelist allowed classes"
    ),
    
    FlashVulnerability(
        cve_id="FLASH-SharedObject",
        name="SharedObject Manipulation",
        category=FlashVulnCategory.DESERIALIZATION,
        severity=Severity.HIGH,
        affected_versions="All Flash versions",
        description="""
SharedObject (.sol files) can be directly edited.
Stores game state, settings, credentials locally.
No integrity verification in most implementations.
""",
        as3_pattern="SharedObject getLocal data flush",
        rag_query="SharedObject getLocal data flush save load",
        exploit_method="""
1. Locate .sol files in Flash storage
2. Decode/edit with SOL editor
3. Modify game state, resources, settings
4. Game loads tampered data
""",
        evony_applicable="""
HIGHLY APPLICABLE to Evony:
- Session data in SharedObject
- City settings, preferences
- Potentially cached game state
Location: %APPDATA%/Macromedia/Flash Player/#SharedObjects/
""",
        detection_in_code=["SharedObject", "getLocal", ".data", "flush"],
        mitigation="Server-side validation, signed data"
    ),
    
    # INJECTION
    FlashVulnerability(
        cve_id="FLASH-ExternalInterface",
        name="ExternalInterface Injection",
        category=FlashVulnCategory.INJECTION,
        severity=Severity.HIGH,
        affected_versions="All Flash versions",
        description="""
ExternalInterface.call() can execute JavaScript.
If parameters are not sanitized, allows XSS.
addCallback() allows JS to call into Flash.
""",
        as3_pattern="ExternalInterface call addCallback",
        rag_query="ExternalInterface call addCallback JavaScript",
        exploit_method="""
1. Find ExternalInterface.call() with user input
2. Inject JavaScript payload
3. Or hook addCallback functions from JS
4. Intercept/modify Flash-JS communication
""",
        evony_applicable="""
Check if Evony uses browser integration:
- Payment systems
- Social features
- Analytics
Any ExternalInterface is hookable from browser
""",
        detection_in_code=["ExternalInterface", "call(", "addCallback"],
        mitigation="Sanitize all parameters, CSP"
    ),
    
    FlashVulnerability(
        cve_id="FLASH-LoaderContext",
        name="Loader Security Domain Bypass",
        category=FlashVulnCategory.INJECTION,
        severity=Severity.MEDIUM,
        affected_versions="All Flash versions",
        description="""
Loader with permissive LoaderContext can load
malicious SWFs into same security domain.
""",
        as3_pattern="Loader LoaderContext SecurityDomain",
        rag_query="Loader LoaderContext SecurityDomain allowCodeImport",
        exploit_method="""
1. Find Loader with loose LoaderContext
2. Load malicious SWF
3. Execute in same security context
4. Access protected resources
""",
        evony_applicable="""
Check how Evony loads:
- Asset SWFs
- Module SWFs
- Any dynamic content
""",
        detection_in_code=["Loader", "LoaderContext", "SecurityDomain", "allowCodeImport"],
        mitigation="Strict LoaderContext, validate loaded content"
    ),
    
    # SECURITY BYPASS
    FlashVulnerability(
        cve_id="FLASH-CrossDomain",
        name="crossdomain.xml Bypass",
        category=FlashVulnCategory.BYPASS,
        severity=Severity.HIGH,
        affected_versions="All Flash versions",
        description="""
Misconfigured crossdomain.xml allows cross-origin requests.
Can bypass same-origin policy entirely.
""",
        as3_pattern="crossdomain.xml Security.loadPolicyFile",
        rag_query="crossdomain Security.loadPolicyFile allowDomain",
        exploit_method="""
1. Check target's crossdomain.xml
2. If allow-access-from domain="*"
3. Create malicious SWF on any domain
4. Make authenticated requests to target
5. Bypass SOP, steal data
""",
        evony_applicable="""
CHECK EVONY SERVERS for crossdomain.xml:
- Main game server
- CDN servers
- API endpoints
If permissive, full SOP bypass possible
""",
        detection_in_code=["loadPolicyFile", "allowDomain", "crossdomain"],
        mitigation="Strict crossdomain.xml whitelist"
    ),
    
    FlashVulnerability(
        cve_id="FLASH-LocalConnection",
        name="LocalConnection Security Bypass",
        category=FlashVulnCategory.BYPASS,
        severity=Severity.MEDIUM,
        affected_versions="All Flash versions",
        description="""
LocalConnection allows SWF-to-SWF communication.
Can be exploited if connection names are predictable.
""",
        as3_pattern="LocalConnection connect send allowDomain",
        rag_query="LocalConnection connect send allowDomain",
        exploit_method="""
1. Discover LocalConnection names
2. Connect from malicious SWF
3. Send/receive messages
4. Potentially control target SWF
""",
        evony_applicable="""
Check if Evony client uses LocalConnection
for any IPC (inter-process communication).
May allow external control.
""",
        detection_in_code=["LocalConnection", "connect", "allowDomain", "send"],
        mitigation="Strong connection names, domain validation"
    ),
    
    # INFORMATION LEAK
    FlashVulnerability(
        cve_id="CVE-2015-3043",
        name="Memory Disclosure via BitmapData",
        category=FlashVulnCategory.INFORMATION_LEAK,
        severity=Severity.MEDIUM,
        affected_versions="Flash 17.0.0.134 and earlier",
        description="""
BitmapData can leak uninitialized memory.
Allows reading sensitive data from memory.
""",
        as3_pattern="BitmapData getPixels histogram",
        rag_query="BitmapData getPixels histogram memory",
        exploit_method="""
1. Create BitmapData with specific parameters
2. Read pixel data
3. Contains uninitialized memory
4. May leak sensitive information
""",
        evony_applicable="""
Less critical but worth checking:
- Any image processing
- Screenshot features
- Graphics manipulation
""",
        detection_in_code=["BitmapData", "getPixels", "histogram"],
        mitigation="Update Flash Player"
    ),
    
    FlashVulnerability(
        cve_id="FLASH-NetConnection",
        name="NetConnection Information Disclosure",
        category=FlashVulnCategory.INFORMATION_LEAK,
        severity=Severity.MEDIUM,
        affected_versions="All Flash versions",
        description="""
NetConnection can reveal server details,
internal IPs, and protocol information.
""",
        as3_pattern="NetConnection connect call",
        rag_query="NetConnection connect call RTMP AMF",
        exploit_method="""
1. Intercept NetConnection traffic
2. Analyze AMF messages
3. Extract server info, endpoints
4. Map internal infrastructure
""",
        evony_applicable="""
Evony uses NetConnection/RTMP:
- Game server communication
- May reveal internal endpoints
- Protocol details exposed
""",
        detection_in_code=["NetConnection", "connect", "RTMP", "call"],
        mitigation="Encrypt traffic, hide internals"
    ),
    
    # LOGIC FLAWS (Evony-specific)
    FlashVulnerability(
        cve_id="EVONY-VectorLength",
        name="Vector Length Corruption",
        category=FlashVulnCategory.LOGIC_FLAW,
        severity=Severity.CRITICAL,
        affected_versions="Pre-mitigation Flash",
        description="""
Vector.<uint> length property corruption gives
arbitrary memory read/write primitive.
Foundation for many Flash exploits.
""",
        as3_pattern="Vector uint length",
        rag_query="Vector uint length Array memory",
        exploit_method="""
1. Find memory corruption primitive
2. Target Vector.<uint> in heap
3. Corrupt length to 0xFFFFFFFF
4. Now have unlimited R/W
5. Write shellcode, redirect execution
""",
        evony_applicable="""
Check all Vector usage in Evony:
- Data arrays
- Troop arrays
- Resource arrays
Length corruption = full control
""",
        detection_in_code=["Vector.<uint>", "Vector.<int>", "Vector.<Number>", ".length"],
        mitigation="Flash heap partitioning (post-2015)"
    ),
    
    FlashVulnerability(
        cve_id="EVONY-Socket",
        name="Raw Socket Manipulation",
        category=FlashVulnCategory.LOGIC_FLAW,
        severity=Severity.HIGH,
        affected_versions="All Flash versions",
        description="""
Socket class allows raw TCP communication.
All data can be intercepted and modified.
XOR encryption (0xAA) is trivially reversible.
""",
        as3_pattern="Socket connect writeBytes readBytes",
        rag_query="Socket connect writeBytes readBytes flush",
        exploit_method="""
1. Intercept Socket communication
2. Decrypt XOR (byte ^ 0xAA)
3. Modify packet data
4. Re-encrypt and forward
5. Full MITM capability
""",
        evony_applicable="""
CRITICAL - Evony's main communication:
- GameClient uses Socket
- All commands go through Socket
- XOR 0xAA encryption is weak
Full packet manipulation possible
""",
        detection_in_code=["Socket", "connect", "writeBytes", "readBytes", "0xAA"],
        mitigation="Strong encryption, packet signing"
    ),
    
    FlashVulnerability(
        cve_id="EVONY-Timer",
        name="Timer/setTimeout Manipulation",
        category=FlashVulnCategory.LOGIC_FLAW,
        severity=Severity.MEDIUM,
        affected_versions="All Flash versions",
        description="""
Client-side timers can be manipulated.
Speed up or slow down game timers.
Bypass cooldowns visually.
""",
        as3_pattern="Timer setTimeout setInterval delay",
        rag_query="Timer setTimeout setInterval delay cooldown",
        exploit_method="""
1. Hook Timer class
2. Modify delay values
3. Speed up all timers
4. Cooldowns expire faster (visual)
5. Or slow down for precise timing
""",
        evony_applicable="""
Evony uses extensive timers:
- Context.timerHandler
- Building timers
- March timers
- Cooldown displays
Client-side only but useful for analysis
""",
        detection_in_code=["Timer", "setTimeout", "setInterval", "timerHandler"],
        mitigation="Server-authoritative timing"
    ),
    
    FlashVulnerability(
        cve_id="EVONY-Reflection",
        name="ActionScript Reflection Abuse",
        category=FlashVulnCategory.LOGIC_FLAW,
        severity=Severity.HIGH,
        affected_versions="All Flash versions",
        description="""
describeType, getDefinitionByName allow
runtime introspection and dynamic instantiation.
Can create arbitrary objects if class names known.
""",
        as3_pattern="getDefinitionByName describeType getQualifiedClassName",
        rag_query="getDefinitionByName describeType getQualifiedClassName reflection",
        exploit_method="""
1. Use describeType to map classes
2. getDefinitionByName to instantiate
3. Create objects without constructor
4. Bypass initialization checks
""",
        evony_applicable="""
Check Evony for reflection usage:
- Dynamic class loading
- Plugin systems
- Command dispatch (string to class)
Can inject custom behavior
""",
        detection_in_code=["getDefinitionByName", "describeType", "getQualifiedClassName"],
        mitigation="Whitelist allowed classes"
    ),
]

# RAG search patterns for each vulnerability
RAG_SEARCH_PATTERNS = {
    "bytearray_uaf": [
        "ByteArray length valueOf",
        "ByteArray prototype override",
        "ByteArray realloc resize",
    ],
    "vector_corruption": [
        "Vector uint length modify",
        "Vector int Array corruption",
        "Vector memory access",
    ],
    "amf_deserialize": [
        "AMF readObject deserialize",
        "registerClassAlias class",
        "IExternalizable readExternal",
    ],
    "socket_intercept": [
        "Socket writeBytes readBytes",
        "Socket connect data XOR",
        "GameClient socket send",
    ],
    "sharedobject": [
        "SharedObject getLocal data",
        "SharedObject flush save",
        "sol file storage",
    ],
    "external_interface": [
        "ExternalInterface call JavaScript",
        "ExternalInterface addCallback",
        "Flash JavaScript bridge",
    ],
    "timer_manipulation": [
        "Timer delay interval",
        "setTimeout setInterval callback",
        "timerHandler cooldown",
    ],
    "loader_context": [
        "Loader LoaderContext security",
        "SecurityDomain allowDomain",
        "SWF load import",
    ],
    "reflection": [
        "getDefinitionByName class",
        "describeType introspect",
        "dynamic class instantiate",
    ],
    "type_confusion": [
        "as Object cast type",
        "dynamic untyped convert",
        "type mismatch coerce",
    ],
}


class FlashVulnerabilityScanner:
    """Scans Evony codebase for Flash vulnerabilities"""
    
    def __init__(self):
        self.vulnerabilities = FLASH_VULNERABILITIES.copy()
        self.findings: List[Dict] = []
        self.rag = None
        self._init_rag()
    
    def _init_rag(self):
        try:
            from evony_rag.rag_v2 import EvonyRAGv2
            self.rag = EvonyRAGv2()
            self.rag.policy.set_mode("full_access")
            print("[+] RAG initialized in full_access mode")
        except Exception as e:
            print(f"[!] RAG not available: {e}")
    
    def scan_all(self):
        """Scan for all Flash vulnerabilities"""
        print("\n" + "="*70)
        print(" FLASH VULNERABILITY SCANNER")
        print(" Evony Flash Version: Target Player 27.0 / ActionScript 3.0")
        print("="*70 + "\n")
        
        print(f"[*] Scanning for {len(self.vulnerabilities)} known Flash vulnerabilities\n")
        
        for vuln in self.vulnerabilities:
            self._scan_for_vulnerability(vuln)
        
        return self.findings
    
    def _scan_for_vulnerability(self, vuln: FlashVulnerability):
        """Scan for a specific vulnerability"""
        print(f"[*] Scanning for {vuln.cve_id}: {vuln.name}")
        
        finding = {
            "cve": vuln.cve_id,
            "name": vuln.name,
            "category": vuln.category.value,
            "severity": vuln.severity.value,
            "locations": [],
            "applicable": vuln.evony_applicable,
        }
        
        if self.rag:
            # Search using RAG query
            try:
                results = self.rag.search_only(vuln.rag_query, k=10)
                for r in results:
                    # Handle different result formats
                    if hasattr(r, 'file'):
                        finding["locations"].append(r.file)
                    elif hasattr(r, 'metadata') and 'file' in r.metadata:
                        finding["locations"].append(r.metadata['file'])
                    elif isinstance(r, dict) and 'file' in r:
                        finding["locations"].append(r['file'])
            except Exception as e:
                print(f"    [!] RAG search error: {e}")
        
        # Also search for detection patterns
        for pattern in vuln.detection_in_code:
            if self.rag:
                try:
                    results = self.rag.search_only(pattern, k=5)
                    for r in results:
                        if hasattr(r, 'file'):
                            if r.file not in finding["locations"]:
                                finding["locations"].append(r.file)
                except:
                    pass
        
        if finding["locations"]:
            print(f"    [+] Found {len(finding['locations'])} potential locations")
        
        self.findings.append(finding)
    
    def generate_report(self) -> str:
        """Generate comprehensive Flash vulnerability report"""
        lines = []
        
        lines.append("# ðŸ”¥ FLASH VULNERABILITY ANALYSIS FOR EVONY\n\n")
        lines.append(f"**Scan Time:** {datetime.now().isoformat()}\n")
        lines.append(f"**Target Flash Version:** 27.0 (ActionScript 3.0)\n")
        lines.append(f"**Vulnerabilities Checked:** {len(self.vulnerabilities)}\n\n")
        
        # Summary
        by_severity = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        for v in self.vulnerabilities:
            by_severity[v.severity.value] += 1
        
        lines.append("## Summary by Severity\n\n")
        lines.append(f"- ðŸ”´ **CRITICAL:** {by_severity['critical']}\n")
        lines.append(f"- ðŸŸ  **HIGH:** {by_severity['high']}\n")
        lines.append(f"- ðŸŸ¡ **MEDIUM:** {by_severity['medium']}\n")
        lines.append(f"- ðŸŸ¢ **LOW:** {by_severity['low']}\n\n")
        
        # By category
        by_cat = {}
        for v in self.vulnerabilities:
            c = v.category.value
            by_cat[c] = by_cat.get(c, 0) + 1
        
        lines.append("## Summary by Category\n\n")
        for c, count in sorted(by_cat.items(), key=lambda x: -x[1]):
            lines.append(f"- **{c}:** {count}\n")
        
        lines.append("\n---\n\n")
        
        # Critical vulnerabilities first
        lines.append("## ðŸ”´ CRITICAL Vulnerabilities\n\n")
        for v in self.vulnerabilities:
            if v.severity == Severity.CRITICAL:
                lines.append(self._format_vulnerability(v))
        
        lines.append("## ðŸŸ  HIGH Severity Vulnerabilities\n\n")
        for v in self.vulnerabilities:
            if v.severity == Severity.HIGH:
                lines.append(self._format_vulnerability(v))
        
        lines.append("## ðŸŸ¡ MEDIUM Severity Vulnerabilities\n\n")
        for v in self.vulnerabilities:
            if v.severity == Severity.MEDIUM:
                lines.append(self._format_vulnerability(v))
        
        # Findings summary
        lines.append("---\n\n## ðŸ“ Code Locations Found\n\n")
        for f in self.findings:
            if f["locations"]:
                lines.append(f"### {f['cve']}: {f['name']}\n")
                for loc in f["locations"][:10]:
                    lines.append(f"- `{loc}`\n")
                lines.append("\n")
        
        return "".join(lines)
    
    def _format_vulnerability(self, v: FlashVulnerability) -> str:
        detection = ", ".join(f"`{d}`" for d in v.detection_in_code[:5])
        return f"""
### {v.cve_id}: {v.name}
**Category:** {v.category.value}  
**Affected Versions:** {v.affected_versions}

**Description:**
{v.description}

**Exploit Method:**
```
{v.exploit_method}
```

**Evony Applicability:**
{v.evony_applicable}

**Detection Patterns:** {detection}

**RAG Query:** `{v.rag_query}`

---
"""


def main():
    scanner = FlashVulnerabilityScanner()
    findings = scanner.scan_all()
    
    print(f"\n[+] Scan complete. Checked {len(scanner.vulnerabilities)} vulnerabilities")
    
    # Generate report
    report = scanner.generate_report()
    output = Path(__file__).parent / "FLASH_VULNERABILITIES.md"
    output.write_text(report, encoding="utf-8")
    print(f"[+] Report saved to: {output}")
    
    # Save JSON
    json_path = Path(__file__).parent / "flash_vulnerabilities.json"
    json_data = []
    for v in scanner.vulnerabilities:
        json_data.append({
            "cve": v.cve_id,
            "name": v.name,
            "category": v.category.value,
            "severity": v.severity.value,
            "affected_versions": v.affected_versions,
            "rag_query": v.rag_query,
            "detection_patterns": v.detection_in_code,
        })
    json_path.write_text(json.dumps(json_data, indent=2), encoding="utf-8")
    print(f"[+] JSON saved to: {json_path}")
    
    # Save findings
    findings_path = Path(__file__).parent / "flash_findings.json"
    findings_path.write_text(json.dumps(findings, indent=2), encoding="utf-8")
    print(f"[+] Findings saved to: {findings_path}")


if __name__ == "__main__":
    main()
