#!/usr/bin/env python3
"""
Hook Point Finder - Discovers all injection points in Evony client
Finds places where code can be hooked, modified, or injected
"""

import sys
import json
import re
from pathlib import Path
from dataclasses import dataclass
from typing import List, Dict, Optional
from enum import Enum

sys.path.insert(0, str(Path(__file__).parent.parent))

class HookType(Enum):
    FUNCTION_HOOK = "function_hook"      # Override function behavior
    EVENT_HOOK = "event_hook"            # Intercept events
    NETWORK_HOOK = "network_hook"        # Intercept network calls
    MEMORY_HOOK = "memory_hook"          # Modify memory values
    TIMER_HOOK = "timer_hook"            # Manipulate timers
    EXTERNAL_HOOK = "external_hook"      # ExternalInterface hooks
    REFLECTION_HOOK = "reflection_hook"  # Dynamic code execution
    STORAGE_HOOK = "storage_hook"        # SharedObject manipulation

@dataclass
class HookPoint:
    name: str
    hook_type: HookType
    location: str
    target: str
    description: str
    hook_method: str
    cheat_potential: str
    example_code: str

# All discoverable hook points
HOOK_PATTERNS = {
    # Function hooks - override game logic
    "function_hooks": [
        {
            "pattern": r"public\s+function\s+(\w+)\s*\([^)]*\)",
            "name": "Public Function",
            "description": "Overridable public function",
            "hook_method": "Replace function pointer or extend class",
        },
        {
            "pattern": r"protected\s+function\s+(\w+)\s*\([^)]*\)",
            "name": "Protected Function", 
            "description": "Subclass can override",
            "hook_method": "Create subclass, override method",
        },
    ],
    
    # Event hooks - intercept game events
    "event_hooks": [
        {
            "pattern": r"addEventListener\s*\(\s*['\"]?(\w+)['\"]?\s*,",
            "name": "Event Listener",
            "description": "Event can be intercepted or faked",
            "hook_method": "dispatchEvent with fake event data",
        },
        {
            "pattern": r"dispatchEvent\s*\(\s*new\s+(\w+)",
            "name": "Event Dispatch",
            "description": "Can inject custom events",
            "hook_method": "Call dispatchEvent with modified data",
        },
    ],
    
    # Network hooks - intercept communications
    "network_hooks": [
        {
            "pattern": r"Socket\s*\(\s*\)|new\s+Socket",
            "name": "Socket Connection",
            "description": "Network socket - intercept all traffic",
            "hook_method": "Proxy socket, modify packets",
        },
        {
            "pattern": r"URLLoader|URLRequest",
            "name": "HTTP Request",
            "description": "HTTP traffic - intercept/modify",
            "hook_method": "MITM proxy, modify requests/responses",
        },
        {
            "pattern": r"sendMessage\s*\(",
            "name": "Game Command Send",
            "description": "Outgoing game command",
            "hook_method": "Hook sendMessage, modify params",
        },
    ],
    
    # Timer hooks - manipulate time
    "timer_hooks": [
        {
            "pattern": r"Timer\s*\(\s*(\d+)",
            "name": "Timer Instance",
            "description": "Client-side timer - speed up/slow down",
            "hook_method": "Override Timer class, modify delay",
        },
        {
            "pattern": r"setTimeout\s*\(|setInterval\s*\(",
            "name": "Delayed Execution",
            "description": "Scheduled code execution",
            "hook_method": "Hook timeout/interval functions",
        },
        {
            "pattern": r"serverTime|clientTime|getTimer",
            "name": "Time Reference",
            "description": "Time value used in calculations",
            "hook_method": "Override time functions to return fake values",
        },
    ],
    
    # External interface hooks
    "external_hooks": [
        {
            "pattern": r"ExternalInterface\.call\s*\(\s*['\"](\w+)['\"]",
            "name": "JS Call from Flash",
            "description": "Flash calling JavaScript",
            "hook_method": "Override JS function in browser",
        },
        {
            "pattern": r"ExternalInterface\.addCallback\s*\(\s*['\"](\w+)['\"]",
            "name": "JS Callback Registration",
            "description": "JavaScript can call into Flash",
            "hook_method": "Call registered function from JS with custom data",
        },
    ],
    
    # Reflection hooks - dynamic code
    "reflection_hooks": [
        {
            "pattern": r"getDefinitionByName\s*\(",
            "name": "Dynamic Class Load",
            "description": "Runtime class resolution",
            "hook_method": "Inject custom class with same name",
        },
        {
            "pattern": r"describeType\s*\(",
            "name": "Type Introspection",
            "description": "Runtime type analysis",
            "hook_method": "Modify type metadata",
        },
        {
            "pattern": r"\[\s*['\"]?\w+['\"]?\s*\]",
            "name": "Bracket Access",
            "description": "Dynamic property access",
            "hook_method": "Inject properties via prototype",
        },
    ],
    
    # Storage hooks - persistent data
    "storage_hooks": [
        {
            "pattern": r"SharedObject\.getLocal\s*\(",
            "name": "Local Storage",
            "description": "Persistent Flash storage",
            "hook_method": "Modify .sol files directly",
        },
        {
            "pattern": r"\.data\s*\[",
            "name": "SharedObject Data",
            "description": "Stored data access",
            "hook_method": "Edit .sol file to change stored values",
        },
    ],
}

# Critical hook targets for cheating
CRITICAL_TARGETS = {
    "Context.getInstance": {
        "type": HookType.FUNCTION_HOOK,
        "cheat": "Access and modify all game state",
        "method": "Hook singleton getter, return modified Context",
    },
    "Sender.sendMessage": {
        "type": HookType.NETWORK_HOOK,
        "cheat": "Modify any outgoing command",
        "method": "Intercept, modify params, forward",
    },
    "ResponseDispatcher.dispatch": {
        "type": HookType.EVENT_HOOK,
        "cheat": "Inject fake server responses",
        "method": "Call dispatch with crafted response data",
    },
    "CastleBean.troop": {
        "type": HookType.MEMORY_HOOK,
        "cheat": "Show fake troop counts",
        "method": "Override getter to return modified values",
    },
    "ResourceBean.amount": {
        "type": HookType.MEMORY_HOOK,
        "cheat": "Display unlimited resources",
        "method": "Hook getter, return MAX_INT",
    },
    "GameClient.socket": {
        "type": HookType.NETWORK_HOOK,
        "cheat": "Full network control",
        "method": "Replace socket with proxy socket",
    },
    "timerHandler": {
        "type": HookType.TIMER_HOOK,
        "cheat": "Speed up all timers",
        "method": "Hook timer callback, accelerate",
    },
    "Utils.serverTime": {
        "type": HookType.TIMER_HOOK,
        "cheat": "Fake server time",
        "method": "Return manipulated time values",
    },
}


class HookFinder:
    """Finds all hookable points in codebase"""
    
    def __init__(self):
        self.hooks: List[HookPoint] = []
        self.rag = None
        self._init_rag()
    
    def _init_rag(self):
        try:
            from evony_rag.rag_v2 import EvonyRAGv2
            self.rag = EvonyRAGv2()
            self.rag.policy.set_mode("full_access")
            print("[+] RAG initialized")
        except:
            print("[!] RAG not available")
    
    def find_all_hooks(self) -> List[HookPoint]:
        """Find all hook points"""
        print("\n" + "="*60)
        print(" HOOK POINT FINDER - INJECTION POINT DISCOVERY")
        print("="*60 + "\n")
        
        # Add critical targets
        self._add_critical_targets()
        
        # Search for patterns
        if self.rag:
            self._search_function_hooks()
            self._search_event_hooks()
            self._search_network_hooks()
            self._search_timer_hooks()
            self._search_external_hooks()
            self._search_reflection_hooks()
            self._search_storage_hooks()
        
        return self.hooks
    
    def _add_critical_targets(self):
        """Add known critical hook targets"""
        print("[*] Adding critical hook targets...")
        
        for target, info in CRITICAL_TARGETS.items():
            hook = HookPoint(
                name=f"CRITICAL: {target}",
                hook_type=info["type"],
                location=f"Search for: {target}",
                target=target,
                description=f"Critical hook target for: {info['cheat']}",
                hook_method=info["method"],
                cheat_potential=info["cheat"],
                example_code=self._get_hook_example(target, info["type"])
            )
            self.hooks.append(hook)
        
        print(f"[+] Added {len(CRITICAL_TARGETS)} critical targets")
    
    def _get_hook_example(self, target: str, hook_type: HookType) -> str:
        """Generate example hook code"""
        examples = {
            HookType.FUNCTION_HOOK: f"""
// Override {target}
var original_{target.replace('.', '_')} = {target};
{target} = function(...args) {{
    console.log("Hooked:", args);
    // Modify args or return value
    return original_{target.replace('.', '_')}.apply(this, args);
}};
""",
            HookType.NETWORK_HOOK: f"""
// Network hook for {target}
class ProxySocket extends Socket {{
    override public function writeBytes(bytes:ByteArray):void {{
        // Log/modify outgoing data
        trace("Outgoing:", bytes.toString());
        super.writeBytes(bytes);
    }}
}}
""",
            HookType.EVENT_HOOK: f"""
// Event hook for {target}
originalDispatch = target.dispatchEvent;
target.dispatchEvent = function(event) {{
    if (event.type == "SERVER_TROOP_UPDATE") {{
        // Modify event data
        event.data.troop.archer = 999999999;
    }}
    return originalDispatch.call(this, event);
}};
""",
            HookType.MEMORY_HOOK: f"""
// Memory hook for {target}
// Using getter override
Object.defineProperty(target, 'amount', {{
    get: function() {{ return 999999999; }},
    set: function(v) {{ /* ignore */ }}
}});
""",
            HookType.TIMER_HOOK: f"""
// Timer speed hack
var originalSetTimeout = setTimeout;
setTimeout = function(fn, delay) {{
    return originalSetTimeout(fn, delay / 10); // 10x faster
}};
""",
        }
        return examples.get(hook_type, "// Custom hook implementation needed")
    
    def _rag_search(self, query: str, k: int = 10) -> List[Dict]:
        if not self.rag:
            return []
        try:
            results = self.rag.search_only(query, k=k)
            return [{"file": r.file, "snippet": r.snippet} for r in results]
        except:
            return []
    
    def _search_function_hooks(self):
        print("[*] Searching for function hooks...")
        queries = [
            "public function handler command action",
            "protected function update refresh callback",
            "override function process calculate",
        ]
        for q in queries:
            results = self._rag_search(q, k=10)
            for r in results:
                self._add_hook_from_result(r, HookType.FUNCTION_HOOK, "Function override point")
    
    def _search_event_hooks(self):
        print("[*] Searching for event hooks...")
        queries = [
            "addEventListener dispatchEvent handler",
            "EVENT_CHANGE UPDATE COMPLETE",
            "PropertyChangeEvent Event dispatch",
        ]
        for q in queries:
            results = self._rag_search(q, k=10)
            for r in results:
                self._add_hook_from_result(r, HookType.EVENT_HOOK, "Event interception point")
    
    def _search_network_hooks(self):
        print("[*] Searching for network hooks...")
        queries = [
            "Socket send receive connect",
            "sendMessage GameClient packet",
            "URLLoader URLRequest load",
        ]
        for q in queries:
            results = self._rag_search(q, k=10)
            for r in results:
                self._add_hook_from_result(r, HookType.NETWORK_HOOK, "Network interception point")
    
    def _search_timer_hooks(self):
        print("[*] Searching for timer hooks...")
        queries = [
            "Timer setTimeout setInterval delay",
            "cooldown endTime startTime duration",
            "serverTime getTimer timestamp",
        ]
        for q in queries:
            results = self._rag_search(q, k=10)
            for r in results:
                self._add_hook_from_result(r, HookType.TIMER_HOOK, "Timer manipulation point")
    
    def _search_external_hooks(self):
        print("[*] Searching for external interface hooks...")
        queries = [
            "ExternalInterface call addCallback",
            "JavaScript Flash bridge",
        ]
        for q in queries:
            results = self._rag_search(q, k=10)
            for r in results:
                self._add_hook_from_result(r, HookType.EXTERNAL_HOOK, "JS-Flash bridge hook")
    
    def _search_reflection_hooks(self):
        print("[*] Searching for reflection hooks...")
        queries = [
            "getDefinitionByName describeType reflect",
            "dynamic class Object prototype",
        ]
        for q in queries:
            results = self._rag_search(q, k=10)
            for r in results:
                self._add_hook_from_result(r, HookType.REFLECTION_HOOK, "Dynamic code injection point")
    
    def _search_storage_hooks(self):
        print("[*] Searching for storage hooks...")
        queries = [
            "SharedObject getLocal data persist",
            "LocalStorage save load cookie",
        ]
        for q in queries:
            results = self._rag_search(q, k=10)
            for r in results:
                self._add_hook_from_result(r, HookType.STORAGE_HOOK, "Persistent storage manipulation")
    
    def _add_hook_from_result(self, result: Dict, hook_type: HookType, description: str):
        # Avoid duplicates
        for h in self.hooks:
            if h.location == result["file"]:
                return
        
        hook = HookPoint(
            name=f"Hook in {Path(result['file']).stem}",
            hook_type=hook_type,
            location=result["file"],
            target=result["snippet"][:100],
            description=description,
            hook_method=f"Implement {hook_type.value} for this location",
            cheat_potential="Requires analysis",
            example_code=self._get_hook_example("target", hook_type)
        )
        self.hooks.append(hook)
    
    def generate_report(self) -> str:
        """Generate hook point report"""
        lines = []
        lines.append("# ðŸŽ£ HOOK POINT DISCOVERY REPORT\n\n")
        lines.append(f"**Total Hook Points Found:** {len(self.hooks)}\n\n")
        
        # Group by type
        by_type = {}
        for h in self.hooks:
            t = h.hook_type.value
            if t not in by_type:
                by_type[t] = []
            by_type[t].append(h)
        
        lines.append("## Summary by Type\n")
        for t, hooks in sorted(by_type.items(), key=lambda x: -len(x[1])):
            lines.append(f"- **{t}**: {len(hooks)} points\n")
        
        lines.append("\n---\n")
        
        # Critical hooks first
        lines.append("\n## ðŸ”´ CRITICAL Hook Points\n")
        for h in self.hooks:
            if "CRITICAL" in h.name:
                lines.append(self._format_hook(h))
        
        # By type
        for hook_type in HookType:
            hooks = [h for h in self.hooks if h.hook_type == hook_type and "CRITICAL" not in h.name]
            if hooks:
                lines.append(f"\n## {hook_type.value.upper()} Points\n")
                for h in hooks[:20]:  # Limit output
                    lines.append(self._format_hook(h))
        
        return "".join(lines)
    
    def _format_hook(self, h: HookPoint) -> str:
        return f"""
### {h.name}
- **Type:** {h.hook_type.value}
- **Location:** `{h.location}`
- **Target:** `{h.target[:80]}...`
- **Cheat Potential:** {h.cheat_potential}
- **Hook Method:** {h.hook_method}

```actionscript
{h.example_code}
```

"""


def main():
    finder = HookFinder()
    hooks = finder.find_all_hooks()
    
    print(f"\n[+] Found {len(hooks)} hook points")
    
    report = finder.generate_report()
    output = Path(__file__).parent / "HOOK_POINTS.md"
    output.write_text(report, encoding="utf-8")
    print(f"[+] Report saved to: {output}")
    
    # Save JSON
    json_path = Path(__file__).parent / "hooks.json"
    data = [{"name": h.name, "type": h.hook_type.value, "location": h.location,
             "target": h.target, "cheat": h.cheat_potential} for h in hooks]
    json_path.write_text(json.dumps(data, indent=2), encoding="utf-8")
    print(f"[+] JSON saved to: {json_path}")


if __name__ == "__main__":
    main()
