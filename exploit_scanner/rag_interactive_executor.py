#!/usr/bin/env python3
"""
RAG INTERACTIVE EXECUTOR
Execute the EPIC RAG ACTION PLAN step by step

Run this script to systematically fill all reverse engineering gaps
"""

import sys
import json
import re
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Optional
from dataclasses import dataclass, field

sys.path.insert(0, str(Path(__file__).parent.parent))

@dataclass
class DiscoveryResult:
    phase: str
    category: str
    name: str
    file: str
    data: Dict = field(default_factory=dict)
    
class RAGInteractiveExecutor:
    """Interactive RAG executor for complete reverse engineering"""
    
    def __init__(self):
        self.rag = None
        self.results: Dict[str, List] = {
            "commands": [],
            "beans": [],
            "constants": [],
            "handlers": [],
            "validations": [],
            "scripts": [],
            "security": [],
        }
        self.progress = {
            "phase1": 0,
            "phase2": 0,
            "phase3": 0,
            "phase4": 0,
            "phase5": 0,
            "phase6": 0,
        }
        self._init_rag()
    
    def _init_rag(self):
        try:
            from evony_rag.rag_v2 import EvonyRAGv2
            self.rag = EvonyRAGv2()
            self.rag.policy.set_mode("full_access")
            print("âœ… RAG initialized in full_access mode")
            print(f"   Chunks: {self.rag.stats.get('chunks', 'N/A')}")
        except Exception as e:
            print(f"âŒ RAG init failed: {e}")
            return
    
    def search(self, query: str, k: int = 20) -> List[Dict]:
        """Execute RAG search and return parsed results"""
        if not self.rag:
            print("âŒ RAG not available")
            return []
        
        print(f"\nğŸ” Searching: {query}")
        try:
            results = self.rag.search_only(query, k=k)
            parsed = []
            for r in results:
                item = {}
                if hasattr(r, 'file'):
                    item['file'] = r.file
                    item['snippet'] = getattr(r, 'snippet', '')
                elif isinstance(r, dict):
                    item = r
                if item:
                    parsed.append(item)
            print(f"   Found {len(parsed)} results")
            return parsed
        except Exception as e:
            print(f"âŒ Search error: {e}")
            return []
    
    # =========================================
    # PHASE 1: PROTOCOL COMMANDS
    # =========================================
    
    def phase1_commands(self):
        """Phase 1: Extract all protocol commands"""
        print("\n" + "="*70)
        print("ğŸ”¥ PHASE 1: PROTOCOL COMMAND EXTRACTION")
        print("="*70)
        
        command_classes = [
            "CommonCommands",
            "TroopCommands", 
            "CityCommands",
            "ArmyCommands",
            "HeroCommands",
            "AllianceCommands",
            "AllianceManagementCommands",
            "TradeCommands",
            "QuestCommands",
            "EquipmentCommands",
            "FieldCommands",
            "ShopCommands",
            "MailCommands",
            "ReportCommands",
            "RankCommands",
            "TechCommands",
            "FortificationCommands",
        ]
        
        all_commands = {}
        
        for cmd_class in command_classes:
            print(f"\nğŸ“‹ Extracting: {cmd_class}")
            
            # Search for the command class
            results = self.search(f"{cmd_class} sendMessage public function", k=25)
            
            commands_found = []
            for r in results:
                snippet = r.get('snippet', '')
                file_path = r.get('file', '')
                
                # Extract command names from sendMessage calls
                cmd_matches = re.findall(r'sendMessage\s*\(\s*"([^"]+)"', snippet)
                for cmd in cmd_matches:
                    if cmd not in commands_found:
                        commands_found.append(cmd)
                        print(f"   âœ… Found: {cmd}")
                
                # Extract function names
                func_matches = re.findall(r'public\s+function\s+(\w+)\s*\(', snippet)
                for func in func_matches:
                    if func not in ['sendMessage', cmd_class]:
                        if func not in commands_found:
                            commands_found.append(f"{cmd_class}.{func}")
            
            all_commands[cmd_class] = commands_found
            self.results["commands"].extend(commands_found)
        
        self.progress["phase1"] = len(self.results["commands"])
        print(f"\nâœ… Phase 1 Complete: {len(self.results['commands'])} commands found")
        return all_commands
    
    # =========================================
    # PHASE 2: BEAN DATA STRUCTURES
    # =========================================
    
    def phase2_beans(self):
        """Phase 2: Extract all bean class fields"""
        print("\n" + "="*70)
        print("ğŸ”¥ PHASE 2: BEAN/DATA STRUCTURE MAPPING")
        print("="*70)
        
        bean_classes = [
            "PlayerBean", "PlayerInfoBean",
            "CastleBean", "CastleResourceBean",
            "HeroBean", "NpcHeroBean",
            "ArmyBean", "TroopBean",
            "ItemBean", "EquipmentBean",
            "BuffBean", "BuildingBean",
            "ResourceBean", "AllianceBean",
            "MailBean", "ReportBean",
            "QuestBean", "TechBean",
            "MapCastleBean", "NpcBean",
            "FortificationsBean", "ColonyBean",
        ]
        
        all_beans = {}
        
        for bean in bean_classes:
            print(f"\nğŸ“¦ Extracting: {bean}")
            
            results = self.search(f"{bean} public var extends BaseBean", k=20)
            
            fields = []
            for r in results:
                snippet = r.get('snippet', '')
                file_path = r.get('file', '')
                
                # Extract field declarations
                field_matches = re.findall(r'public\s+var\s+(\w+)\s*:\s*(\w+)', snippet)
                for name, type_ in field_matches:
                    field_info = f"{name}:{type_}"
                    if field_info not in fields:
                        fields.append(field_info)
                        print(f"   âœ… Field: {name} : {type_}")
                
                # Extract private fields
                priv_matches = re.findall(r'private\s+var\s+_?\d*(\w+)\s*:\s*(\w+)', snippet)
                for name, type_ in priv_matches:
                    field_info = f"_{name}:{type_}"
                    if field_info not in fields:
                        fields.append(field_info)
            
            all_beans[bean] = fields
            self.results["beans"].extend(fields)
        
        self.progress["phase2"] = len(all_beans)
        print(f"\nâœ… Phase 2 Complete: {len(all_beans)} beans analyzed")
        return all_beans
    
    # =========================================
    # PHASE 3: RESPONSE HANDLERS
    # =========================================
    
    def phase3_handlers(self):
        """Phase 3: Map all response handlers"""
        print("\n" + "="*70)
        print("ğŸ”¥ PHASE 3: RESPONSE HANDLER DISCOVERY")
        print("="*70)
        
        # Search for ResponseDispatcher constants
        print("\nğŸ“¡ Searching ResponseDispatcher events...")
        
        results = self.search("ResponseDispatcher public static const", k=50)
        
        handlers = []
        for r in results:
            snippet = r.get('snippet', '')
            
            # Extract event constants
            const_matches = re.findall(
                r'public\s+static\s+const\s+(\w+)\s*:\s*String\s*=\s*"([^"]+)"',
                snippet
            )
            for const_name, event_name in const_matches:
                handler_info = f"{const_name} = {event_name}"
                if handler_info not in handlers:
                    handlers.append(handler_info)
                    print(f"   âœ… Handler: {const_name}")
        
        # Search for addEventListener calls
        print("\nğŸ“¡ Searching event listeners...")
        results = self.search("ResponseDispatcher getInstance addEventListener", k=30)
        
        for r in results:
            snippet = r.get('snippet', '')
            listener_matches = re.findall(
                r'addEventListener\s*\(\s*ResponseDispatcher\.(\w+)',
                snippet
            )
            for listener in listener_matches:
                if listener not in handlers:
                    handlers.append(listener)
                    print(f"   âœ… Listener: {listener}")
        
        self.results["handlers"] = handlers
        self.progress["phase3"] = len(handlers)
        print(f"\nâœ… Phase 3 Complete: {len(handlers)} handlers found")
        return handlers
    
    # =========================================
    # PHASE 4: CONSTANTS & ENUMS
    # =========================================
    
    def phase4_constants(self):
        """Phase 4: Extract all constants and enums"""
        print("\n" + "="*70)
        print("ğŸ”¥ PHASE 4: CONSTANTS & ENUM EXTRACTION")
        print("="*70)
        
        constant_files = [
            "ObjConstants",
            "FieldConstants", 
            "CityStateConstants",
            "TroopConstants",
            "BuildingConstants",
            "ItemConstants",
            "QuestConstants",
            "AllianceConstants",
            "HeroConstants",
        ]
        
        all_constants = {}
        
        for const_file in constant_files:
            print(f"\nğŸ”¢ Extracting: {const_file}")
            
            results = self.search(f"{const_file} public static const int", k=25)
            
            constants = []
            for r in results:
                snippet = r.get('snippet', '')
                
                # Extract constants
                const_matches = re.findall(
                    r'public\s+static\s+const\s+(\w+)\s*:\s*int\s*=\s*(\d+)',
                    snippet
                )
                for name, value in const_matches:
                    const_info = f"{name} = {value}"
                    if const_info not in constants:
                        constants.append(const_info)
                        print(f"   âœ… {name} = {value}")
            
            all_constants[const_file] = constants
            self.results["constants"].extend(constants)
        
        self.progress["phase4"] = len(self.results["constants"])
        print(f"\nâœ… Phase 4 Complete: {len(self.results['constants'])} constants found")
        return all_constants
    
    # =========================================
    # PHASE 5: AUTOEVONY SCRIPTS
    # =========================================
    
    def phase5_scripts(self):
        """Phase 5: Document AutoEvony scripting"""
        print("\n" + "="*70)
        print("ğŸ”¥ PHASE 5: AUTOEVONY SCRIPT ANALYSIS")
        print("="*70)
        
        script_categories = [
            ("flow", "autoevony label goto if else loop while"),
            ("variables", "autoevony set get setarr getarr var"),
            ("city", "autoevony levy comfort build upgrade demolish"),
            ("troops", "autoevony train dismiss fortification"),
            ("army", "autoevony attack scout transport reinforce march"),
            ("npc", "autoevony qfarm attacknpc scan npc"),
            ("hero", "autoevony hirehero firehero awardhero"),
            ("advanced", "autoevony includeurl exec script"),
        ]
        
        all_scripts = {}
        
        for category, query in script_categories:
            print(f"\nğŸ“œ Analyzing: {category}")
            
            results = self.search(query, k=20)
            
            commands = []
            for r in results:
                snippet = r.get('snippet', '')
                file_path = r.get('file', '')
                
                # Store relevant snippets
                if 'autoevony' in file_path.lower() or 'script' in file_path.lower():
                    commands.append({
                        'file': file_path,
                        'snippet': snippet[:200]
                    })
            
            all_scripts[category] = commands
            print(f"   Found {len(commands)} items")
        
        self.results["scripts"] = all_scripts
        self.progress["phase5"] = sum(len(v) for v in all_scripts.values())
        print(f"\nâœ… Phase 5 Complete: {self.progress['phase5']} script items found")
        return all_scripts
    
    # =========================================
    # PHASE 6: SECURITY ANALYSIS
    # =========================================
    
    def phase6_security(self):
        """Phase 6: Security and anti-cheat analysis"""
        print("\n" + "="*70)
        print("ğŸ”¥ PHASE 6: SECURITY/ANTI-CHEAT ANALYSIS")
        print("="*70)
        
        security_queries = [
            ("validation", "if check validate verify require permission"),
            ("session", "session token expire validate refresh"),
            ("rate_limit", "rate limit throttle delay cooldown"),
            ("detection", "detect cheat hack bot suspicious ban"),
            ("integrity", "hash verify signature checksum integrity"),
        ]
        
        all_security = {}
        
        for category, query in security_queries:
            print(f"\nğŸ”’ Analyzing: {category}")
            
            results = self.search(query, k=20)
            
            findings = []
            for r in results:
                snippet = r.get('snippet', '')
                file_path = r.get('file', '')
                
                # Look for security-related patterns
                if any(kw in snippet.lower() for kw in ['valid', 'check', 'secure', 'auth']):
                    findings.append({
                        'file': file_path,
                        'snippet': snippet[:150]
                    })
            
            all_security[category] = findings
            print(f"   Found {len(findings)} items")
        
        self.results["security"] = all_security
        self.progress["phase6"] = sum(len(v) for v in all_security.values())
        print(f"\nâœ… Phase 6 Complete: {self.progress['phase6']} security items found")
        return all_security
    
    # =========================================
    # EXECUTION & REPORTING
    # =========================================
    
    def run_all_phases(self):
        """Execute all phases"""
        print("\n" + "ğŸš€"*35)
        print("   EPIC RAG ACTION PLAN EXECUTOR")
        print("ğŸš€"*35)
        
        # Execute all phases
        self.phase1_commands()
        self.phase2_beans()
        self.phase3_handlers()
        self.phase4_constants()
        self.phase5_scripts()
        self.phase6_security()
        
        # Print summary
        self.print_summary()
        
        # Save results
        self.save_results()
    
    def print_summary(self):
        """Print execution summary"""
        print("\n" + "="*70)
        print("ğŸ“Š EXECUTION SUMMARY")
        print("="*70)
        
        print(f"""
Phase 1 - Commands:    {self.progress['phase1']} items
Phase 2 - Beans:       {self.progress['phase2']} classes
Phase 3 - Handlers:    {self.progress['phase3']} handlers
Phase 4 - Constants:   {self.progress['phase4']} constants
Phase 5 - Scripts:     {self.progress['phase5']} items
Phase 6 - Security:    {self.progress['phase6']} items
{'='*40}
TOTAL DISCOVERED:      {sum(self.progress.values())} items
        """)
    
    def save_results(self):
        """Save all results to files"""
        output_dir = Path(__file__).parent
        
        # Save JSON
        json_path = output_dir / "rag_discovery_results.json"
        json_path.write_text(
            json.dumps({
                "timestamp": datetime.now().isoformat(),
                "progress": self.progress,
                "results": {
                    "commands": self.results["commands"],
                    "beans": self.results["beans"],
                    "constants": self.results["constants"],
                    "handlers": self.results["handlers"],
                }
            }, indent=2, default=str),
            encoding="utf-8"
        )
        print(f"\nâœ… Results saved to: {json_path}")
        
        # Generate report
        self.generate_report(output_dir)
    
    def generate_report(self, output_dir: Path):
        """Generate markdown report"""
        report_path = output_dir / "RAG_DISCOVERY_RESULTS.md"
        
        lines = [
            "# ğŸ“Š RAG DISCOVERY RESULTS\n\n",
            f"**Generated:** {datetime.now().isoformat()}\n\n",
            "---\n\n",
            "## Summary\n\n",
            f"| Phase | Items Found |\n",
            f"|-------|-------------|\n",
            f"| Commands | {self.progress['phase1']} |\n",
            f"| Beans | {self.progress['phase2']} |\n",
            f"| Handlers | {self.progress['phase3']} |\n",
            f"| Constants | {self.progress['phase4']} |\n",
            f"| Scripts | {self.progress['phase5']} |\n",
            f"| Security | {self.progress['phase6']} |\n",
            f"| **TOTAL** | **{sum(self.progress.values())}** |\n\n",
            "---\n\n",
            "## Commands Found\n\n",
        ]
        
        for cmd in self.results["commands"][:50]:
            lines.append(f"- `{cmd}`\n")
        
        lines.append("\n## Constants Found\n\n")
        for const in self.results["constants"][:50]:
            lines.append(f"- `{const}`\n")
        
        lines.append("\n## Handlers Found\n\n")
        for handler in self.results["handlers"][:50]:
            lines.append(f"- `{handler}`\n")
        
        report_path.write_text("".join(lines), encoding="utf-8")
        print(f"âœ… Report saved to: {report_path}")


def main():
    executor = RAGInteractiveExecutor()
    
    print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           ğŸš€ EPIC RAG ACTION PLAN EXECUTOR ğŸš€                    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Options:                                                        â•‘
â•‘    1. Run ALL phases                                             â•‘
â•‘    2. Run Phase 1 (Commands)                                     â•‘
â•‘    3. Run Phase 2 (Beans)                                        â•‘
â•‘    4. Run Phase 3 (Handlers)                                     â•‘
â•‘    5. Run Phase 4 (Constants)                                    â•‘
â•‘    6. Run Phase 5 (Scripts)                                      â•‘
â•‘    7. Run Phase 6 (Security)                                     â•‘
â•‘    0. Exit                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)
    
    choice = input("\nSelect option (1-7, 0 to exit): ").strip()
    
    if choice == "1":
        executor.run_all_phases()
    elif choice == "2":
        executor.phase1_commands()
        executor.save_results()
    elif choice == "3":
        executor.phase2_beans()
        executor.save_results()
    elif choice == "4":
        executor.phase3_handlers()
        executor.save_results()
    elif choice == "5":
        executor.phase4_constants()
        executor.save_results()
    elif choice == "6":
        executor.phase5_scripts()
        executor.save_results()
    elif choice == "7":
        executor.phase6_security()
        executor.save_results()
    elif choice == "0":
        print("Goodbye!")
    else:
        # Default: run all
        executor.run_all_phases()


if __name__ == "__main__":
    main()
